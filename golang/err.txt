cmd\custom-microservice-tester\main.go:42:10: ioutilDeprecated: ioutil.WriteFile is deprecated, use os.WriteFile instead (gocritic)
		err := ioutil.WriteFile("/data/hello-world", []byte("Hello World"), 0644)
		       ^
cmd\custom-microservice-tester\main.go:73:21: Error return value of `http.ListenAndServe` is not checked (errcheck)
	http.ListenAndServe(":9091", serverMuxA)
	                   ^
cmd\custom-microservice-tester\main.go:79:21: Error return value of `http.ListenAndServe` is not checked (errcheck)
	http.ListenAndServe(":81", serverMuxB)
	                   ^
cmd\factoryinput\http.go:12:2: `github.com/gin-contrib/zap` is not in the allowlist (depguard)
	ginzap "github.com/gin-contrib/zap"
	^
cmd\factoryinput\http.go:13:2: `github.com/gin-gonic/gin` is not in the allowlist (depguard)
	"github.com/gin-gonic/gin"
	^
cmd\factoryinput\http.go:46:2: unnecessaryBlock: block doesn't have definitions, can be simply deleted (gocritic)
	{
	^
cmd\factoryinput\http.go:47: line is 165 characters (lll)
		// WARNING: Need to check in each specific handler whether the user is actually allowed to access it, so that valid user "ia" cannot access data for customer "abc"
cmd\factoryinput\http.go:115:20: ioutilDeprecated: ioutil.ReadAll is deprecated, use io.ReadAll instead (gocritic)
	jsonBytes, err := ioutil.ReadAll(c.Request.Body)
	                  ^
cmd\factoryinput\http.go:127:6: shadow: declaration of "postMQTTRequest" shadows declaration at line 98 (govet)
	var postMQTTRequest postMQTTRequest
	    ^
cmd\factoryinput\main.go:13: line is 141 characters (lll)
2. Only one function processing everything. In this function no database calls are allowed to be as stateless as possible (dataprocessing.go)
cmd\factoryinput\main.go:20:2: `github.com/gin-gonic/gin` is not in the allowlist (depguard)
	"github.com/gin-gonic/gin"
	^
cmd\factoryinput\main.go:39:5: emptyStringTest: replace `len(variableName) == 0` with `variableName == ""` (gocritic)
	if len(variableName) == 0 {
	   ^
cmd\factoryinput\main.go:43:5: emptyStringTest: replace `len(envValue) == 0` with `envValue == ""` (gocritic)
	if len(envValue) == 0 {
	   ^
cmd\factoryinput\main.go:111:3: shadow: declaration of "err" shadows declaration at line 105 (govet)
		err := closeQueue()
		^
cmd\factoryinput\main.go:199:2: variable 'err' is only used in the if-statement (\cmd\factoryinput\main.go:200:2); consider using short syntax (ifshort)
	err := closeQueue()
	^
cmd\factoryinput\mqtt.go:20:19: ioutilDeprecated: ioutil.ReadFile is deprecated, use os.ReadFile instead (gocritic)
	pemCerts, err := ioutil.ReadFile("/SSL_certs/intermediate_CA.pem")
	                 ^
cmd\factoryinput\mqtt.go:49:3: G402: TLS InsecureSkipVerify set true. (gosec)
		InsecureSkipVerify: true,
		^
cmd\factoryinput\mqtt.go:73:1: paramTypeCombine: func(certificateName string, mqttBrokerURL string, podName string) MQTT.Client could be replaced with func(certificateName, mqttBrokerURL, podName string) MQTT.Client (gocritic)
func SetupMQTT(certificateName string, mqttBrokerURL string, podName string) MQTT.Client {
^
cmd\factoryinput\mqtt.go:112:7: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
			if err == goque.ErrEmpty {
			   ^
cmd\factoryinput\mqtt.go:126: line is 159 characters (lll)
		token := mqttClient.Publish(fmt.Sprintf("ia/%s/%s/%s/%s", mqttData.Customer, mqttData.Location, mqttData.Asset, mqttData.Value), 2, false, mqttData.JSONData)
cmd\factoryinput\queue.go:31:18: hugeParam: mqttData is heavy (80 bytes); consider passing it by pointer (gocritic)
func enqueueMQTT(mqttData MQTTData) (err error) {
                 ^
cmd\factoryinsight\database.go:9:2: `github.com/gin-gonic/gin` is not in the allowlist (depguard)
	"github.com/gin-gonic/gin"
	^
cmd\factoryinsight\database.go:49:2: variable 'err' is only used in the if-statement (\cmd\factoryinsight\database.go:50:2); consider using short syntax (ifshort)
	err := db.Close()
	^
cmd\factoryinsight\database.go:56:22: `PQErrorHandling` - `c` is unused (unparam)
func PQErrorHandling(c *gin.Context, sqlStatement string, err error, isCritical bool) {
                     ^
cmd\factoryinsight\database.go:98:3: shadow: declaration of "err" shadows declaration at line 84 (govet)
		err := rows.Scan(&location)
		^
cmd\factoryinsight\database.go:113:2: naked return in func `GetLocations` with 35 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:136:3: shadow: declaration of "err" shadows declaration at line 122 (govet)
		err := rows.Scan(&asset)
		^
cmd\factoryinsight\database.go:151:2: naked return in func `GetAssets` with 35 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:174:3: shadow: declaration of "err" shadows declaration at line 160 (govet)
		err := rows.Scan(&component)
		^
cmd\factoryinsight\database.go:189:2: naked return in func `GetComponents` with 35 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:217:2: `if mutex.TryLock(key)` has complex nested blocks (complexity: 9) (nestif)
	if mutex.TryLock(key) { // is is already running?
	^
cmd\factoryinsight\database.go:274:4: shadow: declaration of "err" shadows declaration at line 236 (govet)
			err := rows.Scan(&timestamp, &dataPoint)
			^
cmd\factoryinsight\database.go:302:2: naked return in func `GetStatesRaw` with 110 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:330:2: `if mutex.TryLock(key)` has complex nested blocks (complexity: 10) (nestif)
	if mutex.TryLock(key) { // is is already running?
	^
cmd\factoryinsight\database.go:412:4: shadow: declaration of "err" shadows declaration at line 356 (govet)
			err := rows.Scan(&timestampStart, &timestampEnd, &shiftType)
			^
cmd\factoryinsight\database.go:447:2: naked return in func `GetShiftsRaw` with 142 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:500:2: naked return in func `GetShifts` with 51 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:550:3: shadow: declaration of "err" shadows declaration at line 522 (govet)
		err := rows.Scan(&timestamp, &dataPoint)
		^
cmd\factoryinsight\database.go:568:2: naked return in func `GetProcessValue` with 65 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:617:3: shadow: declaration of "err" shadows declaration at line 589 (govet)
		err := rows.Scan(&timestamp, &dataPoint)
		^
cmd\factoryinsight\database.go:635:2: naked return in func `GetProcessValueString` with 65 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:701:2: naked return in func `GetCurrentState` with 62 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:750:2: naked return in func `GetDataTimeRangeForAsset` with 46 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:776:2: `if mutex.TryLock(key)` has complex nested blocks (complexity: 7) (nestif)
	if mutex.TryLock(key) { // is is already running?
	^
cmd\factoryinsight\database.go:806:4: shadow: declaration of "err" shadows declaration at line 789 (govet)
			err := rows.Scan(&timestamp, &count, &scrapN)
			^
cmd\factoryinsight\database.go:837:2: naked return in func `GetCountsRaw` with 84 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:876:2: naked return in func `GetCounts` with 36 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:882:6: `GetTotalCounts` is unused (deadcode)
func GetTotalCounts(
     ^
cmd\factoryinsight\database.go:917:2: naked return in func `GetTotalCounts` with 36 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:976:3: shadow: declaration of "err" shadows declaration at line 938 (govet)
		err := rows.Scan(&timestamp, &dataPoint)
		^
cmd\factoryinsight\database.go:1018:2: naked return in func `GetProductionSpeed` with 98 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:1080:3: shadow: declaration of "err" shadows declaration at line 1039 (govet)
		err := rows.Scan(&timestamp, &dataPoint)
		^
cmd\factoryinsight\database.go:1122:2: naked return in func `GetQualityRate` with 101 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:1214:2: naked return in func `GetCustomerConfiguration` with 89 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:1264:3: shadow: declaration of "err" shadows declaration at line 1243 (govet)
		err := rows.Scan(
		^
cmd\factoryinsight\database.go:1296:2: naked return in func `GetRecommendations` with 79 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:1339:3: shadow: declaration of "err" shadows declaration at line 1307 (govet)
		err := rows.Scan(&componentName, &activityType, &timestamp)
		^
cmd\factoryinsight\database.go:1358:2: naked return in func `GetMaintenanceActivities` with 59 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:1413:3: shadow: declaration of "err" shadows declaration at line 1377 (govet)
		err := rows.Scan(&UID, &AID, &timestampBegin, &timestampEnd, &productID, &isScrap)
		^
cmd\factoryinsight\database.go:1448:2: naked return in func `GetUniqueProducts` with 87 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:1534:2: naked return in func `GetUpcomingTimeBasedMaintenanceActivities` with 83 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:1613:2: naked return in func `GetOrdersRaw` with 76 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:1673:2: naked return in func `GetUnstartedOrdersRaw` with 57 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:1677: 1677-1740 lines are duplicate of `cmd\factoryinsight\database.go:1742-1809` (dupl)
func GetDistinctProcessValues(c *gin.Context, customerID string, location string, asset string) (
	data []string,
	error error) {
	zap.S().Infof("[GetDistinctProcessValues] customerID: %v, location: %v, asset: %v", customerID, location, asset)

	assetID, err := GetAssetID(c, customerID, location, asset)
	if err != nil {
		error = err
		return
	}

	sqlStatement := `WITH RECURSIVE cte AS (
   (
   SELECT valuename
   FROM   processvaluetable
   ORDER  BY 1
   LIMIT  1
   )
   UNION ALL
   SELECT l.*
   FROM   cte c
   CROSS  JOIN LATERAL (
      SELECT valuename
      FROM   processvaluetable t
      WHERE  t.valuename > c.valuename AND asset_id=$1
      ORDER  BY 1
      LIMIT  1
      ) l
   )
TABLE  cte;`
	rows, err := db.Query(sqlStatement, assetID)
	if err == sql.ErrNoRows {
		PQErrorHandling(c, sqlStatement, err, false)
		return
	} else if err != nil {
		PQErrorHandling(c, sqlStatement, err, false)
		error = err
		return
	}

	defer rows.Close()

	for rows.Next() {
		var currentString string

		err := rows.Scan(&currentString)
		if err != nil {
			PQErrorHandling(c, sqlStatement, err, false)
			error = err
			return
		}

		data = append(data, "process_"+currentString)
	}

	err = rows.Err()
	if err != nil {
		PQErrorHandling(c, sqlStatement, err, false)
		error = err
		return
	}

	return
}
cmd\factoryinsight\database.go:1722:3: shadow: declaration of "err" shadows declaration at line 1682 (govet)
		err := rows.Scan(&currentString)
		^
cmd\factoryinsight\database.go:1739:2: naked return in func `GetDistinctProcessValues` with 63 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:1742: 1742-1809 lines are duplicate of `cmd\factoryinsight\database.go:1677-1740` (dupl)
func GetDistinctProcessValuesString(c *gin.Context, customerID string, location string, asset string) (
	data []string,
	error error) {
	zap.S().Infof(
		"[GetDistinctProcessValuesString] customerID: %v, location: %v, asset: %v",
		customerID,
		location,
		asset)

	assetID, err := GetAssetID(c, customerID, location, asset)
	if err != nil {
		error = err
		return
	}

	sqlStatement := `WITH RECURSIVE cte AS (
   (
   SELECT valuename
   FROM   processvaluestringtable
   ORDER  BY 1
   LIMIT  1
   )
   UNION ALL
   SELECT l.*
   FROM   cte c
   CROSS  JOIN LATERAL (
      SELECT valuename
      FROM   processvaluestringtable t
      WHERE  t.valuename > c.valuename AND asset_id=$1
      ORDER  BY 1
      LIMIT  1
      ) l
   )
TABLE  cte;`
	rows, err := db.Query(sqlStatement, assetID)
	if err == sql.ErrNoRows {
		PQErrorHandling(c, sqlStatement, err, false)
		return
	} else if err != nil {
		PQErrorHandling(c, sqlStatement, err, false)
		error = err
		return
	}

	defer rows.Close()

	for rows.Next() {
		var currentString string

		err := rows.Scan(&currentString)
		if err != nil {
			PQErrorHandling(c, sqlStatement, err, false)
			error = err
			return
		}

		data = append(data, "processString_"+currentString)
	}

	err = rows.Err()
	if err != nil {
		PQErrorHandling(c, sqlStatement, err, false)
		error = err
		return
	}

	return
}
cmd\factoryinsight\database.go:1791:3: shadow: declaration of "err" shadows declaration at line 1751 (govet)
		err := rows.Scan(&currentString)
		^
cmd\factoryinsight\database.go:1808:2: naked return in func `GetDistinctProcessValuesString` with 67 lines of code (nakedret)
	return
	^
cmd\factoryinsight\database.go:1848:1: cognitive complexity 46 of func `GetUniqueProductsWithTags` is high (> 30) (gocognit)
func GetUniqueProductsWithTags(
^
cmd\factoryinsight\database.go:1951:3: shadow: declaration of "err" shadows declaration at line 1859 (govet)
		err := rows.Scan(&UID, &AID, &timestampBegin, &timestampEnd, &productID, &isScrap, &valueName, &value)
		^
cmd\factoryinsight\database.go:1967:3: `if data.Datapoints == nil` has complex nested blocks (complexity: 6) (nestif)
		if data.Datapoints == nil { // if no row in data.Datapoints, create new row
		^
cmd\factoryinsight\database.go:2014:3: shadow: declaration of "err" shadows declaration at line 1859 (govet)
		err := rowsStrings.Scan(&UID, &timestampBegin, &valueName, &value)
		^
cmd\factoryinsight\database.go:2058:3: shadow: declaration of "err" shadows declaration at line 1859 (govet)
		err := rowsInheritance.Scan(&UID, &timestampBegin, &productName, &AID)
		^
cmd\factoryinsight\database.go:2116:1: cognitive complexity 60 of func `GetAccumulatedProducts` is high (> 30) (gocognit)
func GetAccumulatedProducts(
^
cmd\factoryinsight\database.go:2266:3: shadow: declaration of "err" shadows declaration at line 2131 (govet)
		err := insideOrderRows.Scan(&OID, &PID, &timestampBegin, &timestampEnd, &targetUnits, &AID)
		^
cmd\factoryinsight\database.go:2295:2: `if !foundInsider && !foundOutsider` has complex nested blocks (complexity: 19) (nestif)
	if !foundInsider && !foundOutsider {
	^
cmd\factoryinsight\database.go:2385:3: shadow: declaration of "err" shadows declaration at line 2131 (govet)
		err := countRows.Scan(&timestamp, &count, &scrapN)
		^
cmd\factoryinsight\database.go:2432:3: shadow: declaration of "err" shadows declaration at line 2131 (govet)
		err := orderRows.Scan(&orderID, &productId, &targetUnits, &beginTimeStamp, &endTimeStamp)
		^
cmd\factoryinsight\database.go:2485:6: `BeforeOrEqual` is unused (deadcode)
func BeforeOrEqual(t time.Time, u time.Time) bool {
     ^
cmd\factoryinsight\dataprocessing.go:40:33: `BusinessLogicErrorHandling` - `c` is unused (unparam)
func BusinessLogicErrorHandling(c *gin.Context, operationName string, err error, isCritical bool) {
                                ^
cmd\factoryinsight\dataprocessing.go:83:2: Consider pre-allocating `durations` (prealloc)
	var durations []float64
	^
cmd\factoryinsight\dataprocessing.go:113:6: shadow: declaration of "ChannelResult" shadows declaration at line 24 (govet)
	var ChannelResult ChannelResult
	    ^
cmd\factoryinsight\dataprocessing.go:122:2: Consider pre-allocating `stateArray` (prealloc)
	var stateArray []int
	^
cmd\factoryinsight\dataprocessing.go:131:6: shadow: declaration of "ChannelResult" shadows declaration at line 24 (govet)
	var ChannelResult ChannelResult
	    ^
cmd\factoryinsight\dataprocessing.go:161:6: shadow: declaration of "ChannelResult" shadows declaration at line 24 (govet)
	var ChannelResult ChannelResult
	    ^
cmd\factoryinsight\dataprocessing.go:285:2: `if len(processedStates) == 0` has complex nested blocks (complexity: 5) (nestif)
	if len(processedStates) == 0 { // if no value in time range take the previous time stamp.
	^
cmd\factoryinsight\dataprocessing.go:709:1: cognitive complexity 33 of func `calculateOrderInformation` is high (> 30) (gocognit)
func calculateOrderInformation(c *gin.Context, rawOrders []datamodel.OrdersRaw, countSlice []datamodel.CountEntry, assetID uint32, rawStates []datamodel.StateEntry, rawShifts []datamodel.ShiftEntry, configuration datamodel.CustomerConfiguration, location string, asset string) (data datamodel.DataResponseAny, errReturn error) {
^
cmd\factoryinsight\dataprocessing.go:936:2: variable 'loggingTimestamp' is only used in the if-statement (\cmd\factoryinsight\dataprocessing.go:937:2); consider using short syntax (ifshort)
	loggingTimestamp := time.Now()
	^
cmd\factoryinsight\dataprocessing.go:1458:11: ineffectual assignment to err (ineffassign)
	quality, err := CalculateQuality(c, countSlice)
	         ^
cmd\factoryinsight\dataprocessing.go:1483:2: `if mutex.TryLock(key)` has complex nested blocks (complexity: 8) (nestif)
	if mutex.TryLock(key) { // is is already running?
	^
cmd\factoryinsight\dataprocessing.go:1665:3: `if configuration.AutomaticallyIdentifyChangeovers` has complex nested blocks (complexity: 8) (nestif)
		if configuration.AutomaticallyIdentifyChangeovers { // only execute when configuration is set
		^
cmd\factoryinsight\dataprocessing.go:1785:2: variable 'lengthNames' is only used in the if-statement (\cmd\factoryinsight\dataprocessing.go:1786:2); consider using short syntax (ifshort)
	lengthNames := len(names)
	^
cmd\factoryinsight\dataprocessing.go:1834:1: cognitive complexity 57 of func `CalculateAccumulatedProducts` is high (> 30) (gocognit)
func CalculateAccumulatedProducts(c *gin.Context, to time.Time, observationStart time.Time, observationEnd time.Time, countMap []CountStruct, orderMap []OrderStruct, productCache map[int]ProductStruct) (data datamodel.DataResponseAny, error error) {
^
cmd\factoryinsight\dataprocessing_shifts.go:214:2: `if len(overlappingShifts) > 0` has complex nested blocks (complexity: 12) (nestif)
	if len(overlappingShifts) > 0 { // if there are overlapping shifts
	^
cmd\factoryinsight\dataprocessing_shifts_test.go:81:6: `getTestStates` is unused (deadcode)
func getTestStates() (statesArray []datamodel.StateEntry) {
     ^
cmd\factoryinsight\dataprocessing_test.go:23: 23-65 lines are duplicate of `cmd\factoryinsight\dataprocessing_test.go:67-109` (dupl)
func TestAddLowSpeedStates_1(t *testing.T) {
	var stateArray []datamodel.StateEntry
	var configuration datamodel.CustomerConfiguration
	var countSlice []datamodel.CountEntry
	var processedStateArray []datamodel.StateEntry

	err := internal.Load("../../test/factoryinsight/testfiles/addLowSpeedStates_stateArray_1601391491.golden", &stateArray)
	if err != nil {
		fmt.Println(err)
		t.Error()
	}
	err = internal.Load("../../test/factoryinsight/testfiles/addLowSpeedStates_configuration_1601391491.golden", &configuration)
	if err != nil {
		fmt.Println(err)
		t.Error()
	}
	err = internal.Load("../../test/factoryinsight/testfiles/addLowSpeedStates_countSlice_1601391491.golden", &countSlice)
	if err != nil {
		fmt.Println(err)
		t.Error()
	}
	err = internal.Load("../../test/factoryinsight/testfiles/addLowSpeedStates_processedStateArray_1601391491.golden", &processedStateArray)
	if err != nil {
		fmt.Println(err)
		t.Error()
	}

	stateArray = ConvertOldToNewStateEntryArray(stateArray)

	processedStateArrayFresh, err := addLowSpeedStates(nil, 0, stateArray, countSlice, configuration)
	if err != nil {
		t.Error()
	}

	processedStateArrayFresh = ConvertNewToOldStateEntryArray(processedStateArrayFresh)

	if !reflect.DeepEqual(processedStateArrayFresh, processedStateArray) {
		fmt.Println(processedStateArrayFresh)
		fmt.Println(processedStateArray)
		t.Error()
	}

}
cmd\factoryinsight\dataprocessing_test.go:67: 67-109 lines are duplicate of `cmd\factoryinsight\dataprocessing_test.go:111-153` (dupl)
func TestAddLowSpeedStates_2(t *testing.T) { // Complex
	var stateArray []datamodel.StateEntry
	var configuration datamodel.CustomerConfiguration
	var countSlice []datamodel.CountEntry
	var processedStateArray []datamodel.StateEntry

	err := internal.Load("../../test/factoryinsight/testfiles/addLowSpeedStates_stateArray_1601392511.golden", &stateArray)
	if err != nil {
		fmt.Println(err)
		t.Error()
	}
	err = internal.Load("../../test/factoryinsight/testfiles/addLowSpeedStates_configuration_1601392511.golden", &configuration)
	if err != nil {
		fmt.Println(err)
		t.Error()
	}
	err = internal.Load("../../test/factoryinsight/testfiles/addLowSpeedStates_countSlice_1601392511.golden", &countSlice)
	if err != nil {
		fmt.Println(err)
		t.Error()
	}
	err = internal.Load("../../test/factoryinsight/testfiles/addLowSpeedStates_processedStateArray_1601392511.golden", &processedStateArray)
	if err != nil {
		fmt.Println(err)
		t.Error()
	}

	stateArray = ConvertOldToNewStateEntryArray(stateArray)

	processedStateArrayFresh, err := addLowSpeedStates(nil, 0, stateArray, countSlice, configuration)
	if err != nil {
		t.Error()
	}

	processedStateArrayFresh = ConvertNewToOldStateEntryArray(processedStateArrayFresh)

	if !reflect.DeepEqual(processedStateArrayFresh, processedStateArray) {
		fmt.Println(processedStateArrayFresh)
		fmt.Println(processedStateArray)
		t.Error()
	}

}
cmd\factoryinsight\dataprocessing_test.go:111: 111-153 lines are duplicate of `cmd\factoryinsight\dataprocessing_test.go:23-65` (dupl)
func TestAddLowSpeedStates_NoLowSpeed_1(t *testing.T) {
	var stateArray []datamodel.StateEntry
	var configuration datamodel.CustomerConfiguration
	var countSlice []datamodel.CountEntry
	var processedStateArray []datamodel.StateEntry

	err := internal.Load("../../test/factoryinsight/testfiles/addLowSpeedStates_stateArray_1601392325.golden", &stateArray)
	if err != nil {
		fmt.Println(err)
		t.Error()
	}
	err = internal.Load("../../test/factoryinsight/testfiles/addLowSpeedStates_configuration_1601392325.golden", &configuration)
	if err != nil {
		fmt.Println(err)
		t.Error()
	}
	err = internal.Load("../../test/factoryinsight/testfiles/addLowSpeedStates_countSlice_1601392325.golden", &countSlice)
	if err != nil {
		fmt.Println(err)
		t.Error()
	}
	err = internal.Load("../../test/factoryinsight/testfiles/addLowSpeedStates_processedStateArray_1601392325.golden", &processedStateArray)
	if err != nil {
		fmt.Println(err)
		t.Error()
	}

	stateArray = ConvertOldToNewStateEntryArray(stateArray)

	processedStateArrayFresh, err := addLowSpeedStates(nil, 0, stateArray, countSlice, configuration)
	if err != nil {
		t.Error()
	}

	processedStateArrayFresh = ConvertNewToOldStateEntryArray(processedStateArrayFresh)

	if !reflect.DeepEqual(processedStateArrayFresh, processedStateArray) {
		fmt.Println(processedStateArrayFresh)
		fmt.Println(processedStateArray)
		t.Error()
	}

}
cmd\factoryinsight\dataprocessing_test.go:685:2: S1021: should merge variable declaration with assignment on next line (gosimple)
	var columnNames []string
	^
cmd\factoryinsight\dataprocessing_test.go:745:2: S1021: should merge variable declaration with assignment on next line (gosimple)
	var columnNames []string
	^
cmd\factoryinsight\dataprocessing_test.go:858:2: S1021: should merge variable declaration with assignment on next line (gosimple)
	var columnNames []string
	^
cmd\factoryinsight\http.go:9:2: `github.com/gin-contrib/zap` is not in the allowlist (depguard)
	ginzap "github.com/gin-contrib/zap"
	^
cmd\factoryinsight\http.go:48:12: Error return value of `router.Run` is not checked (errcheck)
	router.Run(":80")
	          ^
cmd\factoryinsight\http.go:89:6: shadow: declaration of "getLocationsRequest" shadows declaration at line 83 (govet)
	var getLocationsRequest getLocationsRequest
	    ^
cmd\factoryinsight\http.go:124:6: shadow: declaration of "getAssetsRequest" shadows declaration at line 117 (govet)
	var getAssetsRequest getAssetsRequest
	    ^
cmd\factoryinsight\http.go:160:6: shadow: declaration of "getValuesRequest" shadows declaration at line 152 (govet)
	var getValuesRequest getValuesRequest
	    ^
cmd\factoryinsight\http.go:246:1: cyclomatic complexity 31 of func `getDataHandler` is high (> 30) (gocyclo)
func getDataHandler(c *gin.Context) {
^
cmd\factoryinsight\http.go:248:6: shadow: declaration of "getDataRequest" shadows declaration at line 239 (govet)
	var getDataRequest getDataRequest
	    ^
cmd\factoryinsight\http.go:349:6: shadow: declaration of "getStatesRequest" shadows declaration at line 333 (govet)
	var getStatesRequest getStatesRequest
	    ^
cmd\factoryinsight\http.go:446:1: cognitive complexity 37 of func `processAggregatedStatesRequest` is high (> 30) (gocognit)
func processAggregatedStatesRequest(c *gin.Context, getDataRequest getDataRequest) {
^
cmd\factoryinsight\http.go:455:6: shadow: declaration of "getAggregatedStatesRequest" shadows declaration at line 435 (govet)
	var getAggregatedStatesRequest getAggregatedStatesRequest
	    ^
cmd\factoryinsight\http.go:526:2: `if aggregationType == 0` has complex nested blocks (complexity: 13) (nestif)
	if aggregationType == 0 { // default case. aggregate over everything
	^
cmd\factoryinsight\http.go:621:6: shadow: declaration of "getAvailabilityRequest" shadows declaration at line 608 (govet)
	var getAvailabilityRequest getAvailabilityRequest
	    ^
cmd\factoryinsight\http.go:688:3: `if currentTo.After(to)` has complex nested blocks (complexity: 5) (nestif)
		if currentTo.After(to) { // if the next 24h is out of timerange, only calculate OEE till the last value
		^
cmd\factoryinsight\http.go:744:6: shadow: declaration of "getPerformanceRequest" shadows declaration at line 731 (govet)
	var getPerformanceRequest getPerformanceRequest
	    ^
cmd\factoryinsight\http.go:812:3: `if currentTo.After(to)` has complex nested blocks (complexity: 5) (nestif)
		if currentTo.After(to) { // if the next 24h is out of timerange, only calculate OEE till the last value
		^
cmd\factoryinsight\http.go:867:6: shadow: declaration of "getQualityRequest" shadows declaration at line 854 (govet)
	var getQualityRequest getQualityRequest
	    ^
cmd\factoryinsight\http.go:958:6: shadow: declaration of "getOEERequest" shadows declaration at line 945 (govet)
	var getOEERequest getOEERequest
	    ^
cmd\factoryinsight\http.go:1026:3: `if currentTo.After(to)` has complex nested blocks (complexity: 5) (nestif)
		if currentTo.After(to) { // if the next 24h is out of timerange, only calculate OEE till the last value
		^
cmd\factoryinsight\http.go:1087:6: shadow: declaration of "getStateHistogramRequest" shadows declaration at line 1072 (govet)
	var getStateHistogramRequest getStateHistogramRequest
	    ^
cmd\factoryinsight\http.go:1219:6: shadow: declaration of "getCurrentStateRequest" shadows declaration at line 1166 (govet)
	var getCurrentStateRequest getCurrentStateRequest
	    ^
cmd\factoryinsight\http.go:1240:6: shadow: declaration of "getCountsRequest" shadows declaration at line 1195 (govet)
	var getCountsRequest getCountsRequest
	    ^
cmd\factoryinsight\http.go:1273:6: shadow: declaration of "getShiftsRequest" shadows declaration at line 1170 (govet)
	var getShiftsRequest getShiftsRequest
	    ^
cmd\factoryinsight\http.go:1293:6: shadow: declaration of "getProcessValueRequest" shadows declaration at line 1180 (govet)
	var getProcessValueRequest getProcessValueRequest
	    ^
cmd\factoryinsight\http.go:1316:6: shadow: declaration of "getProcessValueStringRequest" shadows declaration at line 1185 (govet)
	var getProcessValueStringRequest getProcessValueStringRequest
	    ^
cmd\factoryinsight\http.go:1395:6: shadow: declaration of "getOrderRequest" shadows declaration at line 1190 (govet)
	var getOrderRequest getOrderRequest
	    ^
cmd\factoryinsight\http.go:1613:53: `processFactoryLocationsRequest` - `getDataRequest` is unused (unparam)
func processFactoryLocationsRequest(c *gin.Context, getDataRequest getDataRequest) {
                                                    ^
cmd\kafka-bridge\TopicMapProcessors.go:20: line is 155 characters (lll)
// It also initialized the message cache, which prevents duplicate messages from being sent to the Kafka broker and circular messages from being processed.
cmd\kafka-bridge\TopicMapProcessors.go:21:1: paramTypeCombine: func(tp TopicMap, kafkaGroupIdSuffic string, securityProtocol string) could be replaced with func(tp TopicMap, kafkaGroupIdSuffic, securityProtocol string) (gocritic)
func CreateTopicMapProcessors(tp TopicMap, kafkaGroupIdSuffic string, securityProtocol string) {
^
cmd\kafka-bridge\TopicMapProcessors.go:64:2: `if element.Bidirectional` has complex nested blocks (complexity: 20) (nestif)
	if element.Bidirectional {
	^
cmd\kafka-bridge\TopicMapProcessors.go:131:3: ifElseChain: rewrite if-else to switch statement (gocritic)
		if element.SendDirection == ToLocal {
		^
cmd\kafka-bridge\TopicMapProcessors.go:182:5: Error return value of `xxhasher.Write` is not checked (errcheck)
	_, _ = xxhasher.Write(msg.Value)
	   ^
cmd\kafka-bridge\TopicMapProcessors.go:184:6: Error return value of `xxhasher.WriteString` is not checked (errcheck)
		_, _ = xxhasher.WriteString(*msg.TopicPartition.Topic)
		   ^
cmd\kafka-bridge\TopicMapProcessors.go:188:2: Error return value of `binary.Write` is not checked (errcheck)
	_ = binary.Write(buf, binary.LittleEndian, msg.TopicPartition.Partition)
	^
cmd\kafka-bridge\TopicMapProcessors.go:189:5: Error return value of `xxhasher.Write` is not checked (errcheck)
	_, _ = xxhasher.Write(buf.Bytes())
	   ^
cmd\kafka-bridge\TopicMapProcessors.go:193:12: Error return value of `messageCache.GetOrSet` is not checked (errcheck)
	getOrSet, _ := messageCache.GetOrSet(key[:], []byte{1}, 0)
	          ^
cmd\kafka-bridge\TopicMapProcessors.go:259:3: appendCombine: can combine chain of 2 appends into one (gocritic)
		msg.Headers = append(
		^
cmd\kafka-bridge\main.go:12:2: G108: Profiling endpoint is automatically exposed on /debug/pprof (gosec)
	_ "net/http/pprof"
	^
cmd\kafka-bridge\main.go:174:1: cognitive complexity 31 of func `PerformanceReport` is high (> 30) (gocognit)
func PerformanceReport() {
^
cmd\kafka-debug\kafka.go:11:34: Error return value of `internal.KafkaConsumer.Subscribe` is not checked (errcheck)
	internal.KafkaConsumer.Subscribe("^ia.+", nil)
	                                ^
cmd\kafka-debug\kafka.go:16:7: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
			if err.(kafka.Error).Code() == kafka.ErrTimedOut {
			   ^
cmd\kafka-init\main.go:4:2: `github.com/confluentinc/confluent-kafka-go/kafka` is not in the allowlist (depguard)
	"github.com/confluentinc/confluent-kafka-go/kafka"
	^
cmd\kafka-state-detector\activityKafka.go:6:2: `github.com/json-iterator/go` is not in the allowlist (depguard)
	jsoniter "github.com/json-iterator/go"
	^
cmd\kafka-state-detector\anomalyKafka.go:6:2: `github.com/json-iterator/go` is not in the allowlist (depguard)
	jsoniter "github.com/json-iterator/go"
	^
cmd\kafka-state-detector\anomalyKafka.go:86:4: unnecessaryBlock: case statement doesn't require a block statement (gocritic)
			{
			^
cmd\kafka-state-detector\anomalyKafka.go:99:4: unnecessaryBlock: case statement doesn't require a block statement (gocritic)
			{
			^
cmd\kafka-state-detector\kafkaMessageStreamQueue_test.go:4:2: `github.com/go-playground/assert/v2` is not in the allowlist (depguard)
	"github.com/go-playground/assert/v2"
	^
cmd\kafka-state-detector\main.go:12:2: G108: Profiling endpoint is automatically exposed on /debug/pprof (gosec)
	_ "net/http/pprof"
	^
cmd\kafka-state-detector\main.go:128:80: G404: Use of weak random number generator (math/rand instead of crypto/rand) (gosec)
				"group.id":                 fmt.Sprintf("kafka-state-detector-anomaly-%d", rand.Uint64()),
				                                                                           ^
cmd\kafka-to-blob\kafka.go:6:2: `github.com/confluentinc/confluent-kafka-go/kafka` is not in the allowlist (depguard)
	"github.com/confluentinc/confluent-kafka-go/kafka"
	^
cmd\kafka-to-blob\kafka.go:8:2: `github.com/minio/minio-go/v7` is not in the allowlist (depguard)
	"github.com/minio/minio-go/v7"
	^
cmd\kafka-to-blob\kafka.go:14:1: paramTypeCombine: func(topic string, bucketName string) could be replaced with func(topic, bucketName string) (gocritic)
func processKafkaQueue(topic string, bucketName string) {
^
cmd\kafka-to-blob\kafka.go:29:4: ifElseChain: rewrite if-else to switch statement (gocritic)
			if err.(kafka.Error).Code() == kafka.ErrTimedOut {
			^
cmd\kafka-to-blob\kafka.go:33:14: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
			} else if err.(kafka.Error).Code() == kafka.ErrUnknownTopicOrPart {
			          ^
cmd\kafka-to-blob\kafka.go:63:1: paramTypeCombine: func(imgBytes []byte, uid string, bucketName string, msg *kafka.Message) could be replaced with func(imgBytes []byte, uid, bucketName string, msg *kafka.Message) (gocritic)
func pushToMinio(imgBytes []byte, uid string, bucketName string, msg *kafka.Message) {
^
cmd\kafka-to-blob\kafka.go:74:33: Error return value of `internal.KafkaProducer.Produce` is not checked (errcheck)
		internal.KafkaProducer.Produce(
		                              ^
cmd\kafka-to-blob\main.go:4:2: `github.com/confluentinc/confluent-kafka-go/kafka` is not in the allowlist (depguard)
	"github.com/confluentinc/confluent-kafka-go/kafka"
	^
cmd\kafka-to-blob\main.go:5:2: `github.com/minio/minio-go/v7` is not in the allowlist (depguard)
	"github.com/minio/minio-go/v7"
	^
cmd\kafka-to-blob\minio.go:5:2: `github.com/minio/minio-go/v7` is not in the allowlist (depguard)
	"github.com/minio/minio-go/v7"
	^
cmd\kafka-to-blob\minio.go:6:2: `github.com/minio/minio-go/v7/pkg/credentials` is not in the allowlist (depguard)
	"github.com/minio/minio-go/v7/pkg/credentials"
	^
cmd\kafka-to-blob\minio.go:11:17: captLocal: `MinioUrl' should not be capitalized (gocritic)
func setupMinio(MinioUrl string, MinioAccessKey string, MinioSecretKey string, MinioSecure bool, MinioBucketName string) (mioClient *minio.Client) {
                ^
cmd\kafka-to-blob\minio.go:44:2: unnecessaryDefer: defer healthCheck() is placed just before return (gocritic)
	defer healthCheck()
	^
cmd\kafka-to-blob\rawImage.go:3:8: `github.com/json-iterator/go` is not in the allowlist (depguard)
import jsoniter "github.com/json-iterator/go"
       ^
cmd\kafka-to-blob\rawImage.go:19:1: typeDefFirst: definition of type 'RawImage' should appear before its methods (gocritic)
type RawImage struct {
^
cmd\kafka-to-postgresql\cache.go:36:2: Error return value of `dbcache.Set` is not checked (errcheck)
	_ = dbcache.Set(key, Uint32ToBytes(value), 0)
	^
cmd\kafka-to-postgresql\database.go:109:21: Error return value of `regexp.MatchString` is not checked (errcheck)
	matchedOutOfRange, _ := regexp.MatchString(`pq: value "-*\d+" is out of range for type integer`, errorString)
	                   ^
cmd\kafka-to-postgresql\database.go:110:23: Error return value of `regexp.MatchString` is not checked (errcheck)
	matchedTsOutOfRange, _ := regexp.MatchString(`pq: timestamp out of range: .+`, errorString)
	                     ^
cmd\kafka-to-postgresql\database.go:132:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == sql.ErrNoRows {
	   ^
cmd\kafka-to-postgresql\database.go:160:2: naked return in func `GetAssetTableID` with 41 lines of code (nakedret)
	return
	^
cmd\kafka-to-postgresql\database.go:190:6: ineffectual assignment to txn (ineffassign)
	var txn *sql.Tx = nil
	    ^
cmd\kafka-to-postgresql\database.go:243:2: naked return in func `GetProductTableId` with 32 lines of code (nakedret)
	return
	^
cmd\kafka-to-postgresql\database.go:290:2: naked return in func `GetUniqueProductID` with 33 lines of code (nakedret)
	return
	^
cmd\kafka-to-postgresql\database.go:327:2: naked return in func `GetLatestParentUniqueProductID` with 34 lines of code (nakedret)
	return
	^
cmd\kafka-to-postgresql\highIntegrityKafka.go:47:2: variable 'err' is only used in the if-statement (\cmd\kafka-to-postgresql\highIntegrityKafka.go:48:2); consider using short syntax (ifshort)
	err := HIKafkaConsumer.Close()
	^
cmd\kafka-to-postgresql\highIntegrityProcessor.go:10:1: cognitive complexity 32 of func `startHighIntegrityQueueProcessor` is high (> 30) (gocognit)
func startHighIntegrityQueueProcessor() {
^
cmd\kafka-to-postgresql\highIntegrityProcessor.go:89:3: `if err != nil` has complex nested blocks (complexity: 7) (nestif)
		if err != nil {
		^
cmd\kafka-to-postgresql\highThroughputKafka.go:39:2: variable 'err' is only used in the if-statement (\cmd\kafka-to-postgresql\highThroughputKafka.go:40:2); consider using short syntax (ifshort)
	err := HTKafkaConsumer.Close()
	^
cmd\kafka-to-postgresql\main.go:338:1: cognitive complexity 31 of func `PerformanceReport` is high (> 30) (gocognit)
func PerformanceReport() {
^
cmd\kafka-to-postgresql\pxAddOrder.go:29:6: ineffectual assignment to txn (ineffassign)
	var txn *sql.Tx = nil
	    ^
cmd\kafka-to-postgresql\pxAddOrder.go:88:20: string `23P01` has 16 occurrences, make it a constant (goconst)
		if pqErr.Code == "23P01" {
		                 ^
cmd\kafka-to-postgresql\pxAddParentToChild.go:29:6: ineffectual assignment to txn (ineffassign)
	var txn *sql.Tx = nil
	    ^
cmd\kafka-to-postgresql\pxMaintenanceActivity.go:71:20: ineffectual assignment to success (ineffassign)
	ComponentTableId, success := GetComponentID(AssetTableID, *sC.ComponentName)
	                  ^
cmd\kafka-to-postgresql\pxModifyProducedPieces.go:28:1: cognitive complexity 36 of func `(ModifyProducedPieces).ProcessMessages` is high (> 30) (gocognit)
func (c ModifyProducedPieces) ProcessMessages(msg internal.ParsedMessage) (putback bool, err error, forcePbTopic bool) {
^
cmd\kafka-to-postgresql\pxModifyProducedPieces.go:87:2: `if sC.Count != nil && *sC.Count >= 0` has complex nested blocks (complexity: 8) (nestif)
	if sC.Count != nil && *sC.Count >= 0 {
	^
cmd\kafka-to-postgresql\pxModifyState.go:92:2: `if val.Next()` has complex nested blocks (complexity: 6) (nestif)
	if val.Next() {
	^
cmd\kafka-to-postgresql\pxProcessValue.go:106:1: cognitive complexity 52 of func `writeProcessValueToDatabase` is high (> 30) (gocognit)
func writeProcessValueToDatabase(messages []*kafka.Message) (
^
cmd\kafka-to-postgresql\pxProcessValue.go:136:2: variable 'toCommit' is only used in the if-statement (\cmd\kafka-to-postgresql\pxProcessValue.go:278:2); consider using short syntax (ifshort)
	toCommit := float64(0)
	^
cmd\kafka-to-postgresql\pxProcessValue.go:283:28: string `AssetID not found` has 4 occurrences, make it a constant (goconst)
		return putBackMsg, true, "AssetID not found", nil
		                         ^
cmd\kafka-to-postgresql\pxProcessValueString.go:110:1: cognitive complexity 62 of func `writeProcessValueStringToDatabase` is high (> 30) (gocognit)
func writeProcessValueStringToDatabase(messages []*kafka.Message) (
^
cmd\kafka-to-postgresql\pxProcessValueString.go:193:4: `if timestampInParsedMessagePayload` has complex nested blocks (complexity: 5) (nestif)
			if timestampString, timestampInParsedMessagePayload := sC["timestamp_ms"]; timestampInParsedMessagePayload {
			^
cmd\kafka-to-postgresql\pxProcessValueString.go:284:2: `if isDryRun` has complex nested blocks (complexity: 5) (nestif)
	if isDryRun {
	^
cmd\kafka-to-postgresql\statements.go:146:2: naked return in func `Shutdown` with 72 lines of code (nakedret)
	return
	^
cmd\mqtt-bridge\main.go:13:2: G108: Profiling endpoint is automatically exposed on /debug/pprof (gosec)
	_ "net/http/pprof"
	^
cmd\mqtt-bridge\main.go:26:7: `localMQTTClientID` is unused (deadcode)
const localMQTTClientID = "MQTT-BRIDGE-LOCAL"
      ^
cmd\mqtt-bridge\main.go:27:7: `remoteMQTTClientID` is unused (deadcode)
const remoteMQTTClientID = "MQTT-BRIDGE-REMOTE"
      ^
cmd\mqtt-bridge\main.go:43:24: Error return value of `http.ListenAndServe` is not checked (errcheck)
	go http.ListenAndServe("localhost:1337", nil)
	                      ^
cmd\mqtt-bridge\main.go:83:18: Error return value is not checked (errcheck)
	defer closeQueue(remotePg)
	                ^
cmd\mqtt-bridge\main.go:90:18: Error return value is not checked (errcheck)
	defer closeQueue(localPg)
	                ^
cmd\mqtt-bridge\main.go:95: line is 208 characters (lll)
	remoteMQTTClient = setupMQTT(remoteCertificateName, "remote", remoteMQTTBrokerURL, remoteSubMQTTTopic, remoteMQTTBrokerSSLEnabled, remotePg, !BRIDGE_ONE_WAY) // make remote subscription dependent on variable
cmd\mqtt-bridge\main.go:96: line is 187 characters (lll)
	localMQTTClient = setupMQTT(localCertificateName, "local", localMQTTBrokerURL, localSubMQTTTopic, localMQTTBrokerSSLEnabled, localPg, true)                   // always subscribe to local
cmd\mqtt-bridge\main.go:142: line is 124 characters (lll)
// publishQueueToBroker starts an endless loop and publishes the given queue element by element to the selected MQTT broker.
cmd\mqtt-bridge\main.go:144:1: paramTypeCombine: func(pq *goque.Queue, client MQTT.Client, prefix string, subMQTTTopic string, pubMQTTTopic string) could be replaced with func(pq *goque.Queue, client MQTT.Client, prefix, subMQTTTopic, pubMQTTTopic string) (gocritic)
func publishQueueToBroker(pq *goque.Queue, client MQTT.Client, prefix string, subMQTTTopic string, pubMQTTTopic string) {
^
cmd\mqtt-bridge\main.go:179:3: SA4006: this value of `topElement` is never used (staticcheck)
		topElement, err = pq.Dequeue()
		^
cmd\mqtt-bridge\mqtt.go:14:1: paramTypeCombine: func(clientID string, mode string) *tls.Config could be replaced with func(clientID, mode string) *tls.Config (gocritic)
func newTLSConfig(clientID string, mode string) *tls.Config {
^
cmd\mqtt-bridge\mqtt.go:20:19: ioutilDeprecated: ioutil.ReadFile is deprecated, use os.ReadFile instead (gocritic)
	pemCerts, err := ioutil.ReadFile("/SSL_certs/" + mode + "/ca.crt")
	                 ^
cmd\mqtt-bridge\mqtt.go:49:3: G402: TLS InsecureSkipVerify set true. (gosec)
		InsecureSkipVerify: true,
		^
cmd\mqtt-bridge\mqtt.go:55: line is 127 characters (lll)
// getOnMessageRecieved gets the function onMessageReceived, that is called everytime a message is received by a specific topic
cmd\mqtt-bridge\mqtt.go:82:89: captLocal: `SSLEnabled' should not be capitalized (gocritic)
func setupMQTT(clientID string, mode string, mqttBrokerURL string, subMQTTTopic string, SSLEnabled bool, pg *goque.Queue, subscribeToTopic bool) (MQTTClient MQTT.Client) {
                                                                                        ^
cmd\mqtt-bridge\mqtt.go:111: line is 128 characters (lll)
		if token := MQTTClient.Subscribe(subMQTTTopic+"/#", 2, getOnMessageRecieved(mode, pg)); token.Wait() && token.Error() != nil {
cmd\mqtt-bridge\mqtt.go:116:2: naked return in func `setupMQTT` with 35 lines of code (nakedret)
	return
	^
cmd\mqtt-bridge\queue.go:36:58: `storeMessageIntoQueue` - `mode` is unused (unparam)
func storeMessageIntoQueue(topic string, message []byte, mode string, pq *goque.Queue) {
                                                         ^
cmd\mqtt-kafka-bridge\hash.go:10:62: builtinShadow: shadowing of predeclared identifier: new (gocritic)
func CheckIfNewMessageOrStore(message []byte, topic string) (new bool) {
                                                             ^
cmd\mqtt-kafka-bridge\kafka.go:83:4: ifElseChain: rewrite if-else to switch statement (gocritic)
			if err.(kafka.Error).Code() == kafka.ErrTimedOut {
			^
cmd\mqtt-kafka-bridge\kafka.go:87:14: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
			} else if err.(kafka.Error).Code() == kafka.ErrUnknownTopicOrPart {
			          ^
cmd\mqtt-kafka-bridge\main.go:60:18: Error return value is not checked (errcheck)
	defer closeQueue(mqttIncomingQueue)
	                ^
cmd\mqtt-kafka-bridge\main.go:85:6: shadow: declaration of "err" shadows declaration at line 54 (govet)
		_, err := os.Open("/SSL_certs/tls.key")
		   ^
cmd\mqtt-kafka-bridge\mqtt.go:18:19: `newTLSConfig` - `clientID` is unused (unparam)
func newTLSConfig(clientID string) *tls.Config {
                  ^
cmd\mqtt-kafka-bridge\mqtt.go:24:19: ioutilDeprecated: ioutil.ReadFile is deprecated, use os.ReadFile instead (gocritic)
	pemCerts, err := ioutil.ReadFile("/SSL_certs/ca.crt")
	                 ^
cmd\mqtt-kafka-bridge\mqtt.go:53:3: G402: TLS InsecureSkipVerify set true. (gosec)
		InsecureSkipVerify: true,
		^
cmd\mqtt-kafka-bridge\mqtt.go:59: line is 127 characters (lll)
// getOnMessageReceived gets the function onMessageReceived, that is called everytime a message is received by a specific topic
cmd\mqtt-kafka-bridge\mqtt.go:177:10: nilness: impossible condition: nil != nil (govet)
		if err != nil {
		       ^
cmd\mqtt-to-postgresql\database.go:120:2: variable 'err2' is only used in the if-statement (\cmd\mqtt-to-postgresql\database.go:121:2); consider using short syntax (ifshort)
	err2 := txn.Rollback()
	^
cmd\mqtt-to-postgresql\database.go:161:2: `if isDryRun` has complex nested blocks (complexity: 9) (nestif)
	if isDryRun {
	^
cmd\mqtt-to-postgresql\database.go:165:7: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
			if errOut != sql.ErrTxDone {
			   ^
cmd\mqtt-to-postgresql\database.go:175:7: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
			if errOut != sql.ErrTxDone {
			   ^
cmd\mqtt-to-postgresql\database.go:516: 516-616 lines are duplicate of `cmd\mqtt-to-postgresql\database.go:730-829` (dupl)
func storeItemsIntoDatabaseProcessValueFloat64(items []*goque.PriorityItem) (faultyItems []*goque.PriorityItem, err error) {
	if len(items) == 0 {
		faultyItems = []*goque.PriorityItem{}
		return
	}

	var txn *sql.Tx = nil
	txn, err = db.Begin()
	if err != nil {
		faultyItems = items

		return
	}

	defer func() {
		errx := CommitOrRollbackOnError(txn, err)
		if errx != nil {
			err = errx

			return
		}
	}()

	// 1. Prepare statement: create temp table
	// These statements' auto close
	{
		stmt := txn.Stmt(statement.CreateTmpProcessValueTable64)
		_, err = stmt.Exec()
		if err != nil {
			faultyItems = items

			return
		}
	}
	// 2. Prepare statement: copying into temp table
	{
		var stmt *sql.Stmt
		stmt, err = txn.Prepare(pq.CopyIn("tmp_processvaluetable64", "timestamp", "asset_id", "value", "valuename"))
		if err != nil {
			faultyItems = items

			return
		}

		for _, item := range items {
			var pt processValueQueueF64
			err = item.ToObjectFromJSON(&pt)
			if err != nil {
				zap.S().Errorf("Failed to unmarshal item", item)
				continue
			}

			timestamp := time.Unix(0, int64(pt.TimestampMs*uint64(1000000))).Format("2006-01-02T15:04:05.000Z")

			_, err = stmt.Exec(timestamp, pt.DBAssetID, pt.ValueFloat64, pt.Name)
			if err != nil {
				faultyItems = append(faultyItems, item)

				err = nil
				continue

			}
		}
		err = stmt.Close()
		if err != nil {
			faultyItems = items

			return
		}

	}

	// 3. Prepare statement: copy from temp table into main table
	{
		var stmt *sql.Stmt
		stmt, err = txn.Prepare(`
			INSERT INTO processvaluetable (SELECT * FROM tmp_processvaluetable64) ON CONFLICT DO NOTHING;
		`)
		if err != nil {
			faultyItems = items

			return
		}

		_, err = stmt.Exec()
		if err != nil {
			faultyItems = items

			return
		}

		err = stmt.Close()
		if err != nil {
			faultyItems = items

			return
		}
	}

	return
}
cmd\mqtt-to-postgresql\database.go:682:20: SA4010: this result of append is never used, except maybe in other appends (staticcheck)
				workingItems = append(workingItems, item)
				               ^
cmd\mqtt-to-postgresql\database.go:686:3: SA9003: empty branch (staticcheck)
		if err != nil {
		^
cmd\mqtt-to-postgresql\database.go:730: 730-829 lines are duplicate of `cmd\mqtt-to-postgresql\database.go:832-933` (dupl)
func storeItemsIntoDatabaseProcessValue(items []*goque.PriorityItem) (faultyItems []*goque.PriorityItem, err error) {
	if len(items) == 0 {
		faultyItems = []*goque.PriorityItem{}
		return
	}

	var txn *sql.Tx = nil
	txn, err = db.Begin()
	if err != nil {
		faultyItems = items

		return
	}

	defer func() {
		errx := CommitOrRollbackOnError(txn, err)
		if errx != nil {
			err = errx

			return
		}
	}()

	// 1. Prepare statement: create temp table
	// These statements' auto close
	{
		stmt := txn.Stmt(statement.CreateTmpProcessValueTable)
		_, err = stmt.Exec()
		if err != nil {
			faultyItems = items

			return
		}
	}
	// 2. Prepare statement: copying into temp table
	{
		var stmt *sql.Stmt
		stmt, err = txn.Prepare(pq.CopyIn("tmp_processvaluetable", "timestamp", "asset_id", "value", "valuename"))
		if err != nil {
			faultyItems = items

			return
		}
		for _, item := range items {
			var pt processValueQueueI32
			err = item.ToObjectFromJSON(&pt)
			if err != nil {
				zap.S().Errorf("Failed to unmarshal item", item)
				continue
			}

			timestamp := time.Unix(0, int64(pt.TimestampMs*uint64(1000000))).Format("2006-01-02T15:04:05.000Z")

			_, err = stmt.Exec(timestamp, pt.DBAssetID, pt.ValueInt32, pt.Name)
			if err != nil {
				faultyItems = append(faultyItems, item)

				err = nil
				continue

			}
		}

		err = stmt.Close()
		if err != nil {
			faultyItems = items

			return
		}
	}

	// 3. Prepare statement: copy from temp table into main table
	{
		var stmt *sql.Stmt
		stmt, err = txn.Prepare(`
			INSERT INTO processvaluetable (SELECT * FROM tmp_processvaluetable) ON CONFLICT DO NOTHING;
		`)
		if err != nil {
			faultyItems = items

			return
		}

		_, err = stmt.Exec()
		if err != nil {
			faultyItems = items

			return
		}

		err = stmt.Close()
		if err != nil {
			faultyItems = items

			return
		}
	}

	return
}
cmd\mqtt-to-postgresql\database.go:832: 832-933 lines are duplicate of `cmd\mqtt-to-postgresql\database.go:516-616` (dupl)
func storeItemsIntoDatabaseCount(items []*goque.PriorityItem) (faultyItems []*goque.PriorityItem, err error) {
	if len(items) == 0 {
		faultyItems = []*goque.PriorityItem{}
		return
	}

	var txn *sql.Tx = nil
	txn, err = db.Begin()
	if err != nil {
		faultyItems = items

		return
	}

	defer func() {
		errx := CommitOrRollbackOnError(txn, err)
		if errx != nil {
			err = errx

			return
		}
	}()

	// 1. Prepare statement: create temp table
	// These statements' auto close
	{
		stmt := txn.Stmt(statement.CreateTmpCountTable)
		_, err = stmt.Exec()
		if err != nil {
			faultyItems = items

			return
		}
	}
	// 2. Prepare statement: copying into temp table
	{
		var stmt *sql.Stmt
		stmt, err = txn.Prepare(pq.CopyIn("tmp_counttable", "timestamp", "asset_id", "count", "scrap"))
		if err != nil {
			faultyItems = items

			return
		}

		for _, item := range items {
			var pt countQueue
			err = item.ToObjectFromJSON(&pt)
			if err != nil {
				zap.S().Errorf("Failed to unmarshal item", item)
				continue
			}

			timestamp := time.Unix(0, int64(pt.TimestampMs*uint64(1000000))).Format("2006-01-02T15:04:05.000Z")

			_, err = stmt.Exec(timestamp, pt.DBAssetID, pt.Count, pt.Scrap)
			if err != nil {
				faultyItems = append(faultyItems, item)

				err = nil
				continue

			}
		}

		err = stmt.Close()
		if err != nil {
			faultyItems = items

			return
		}

	}

	// 3. Prepare statement: copy from temp table into main table
	{
		var stmt *sql.Stmt
		stmt, err = txn.Prepare(`
			INSERT INTO counttable (SELECT * FROM tmp_counttable) ON CONFLICT DO NOTHING;
		`)
		if err != nil {
			faultyItems = items

			return
		}

		_, err = stmt.Exec()
		if err != nil {
			faultyItems = items

			return
		}

		err = stmt.Close()
		if err != nil {
			faultyItems = items

			return
		}
	}

	return
}
cmd\mqtt-to-postgresql\database.go:935: 935-978 lines are duplicate of `cmd\mqtt-to-postgresql\database.go:980-1025` (dupl)
func storeItemsIntoDatabaseState(items []*goque.PriorityItem, recursionDepth int) (faultyItems []*goque.PriorityItem, err error) {
	if len(items) == 0 {
		faultyItems = []*goque.PriorityItem{}
		return
	}

	var txn *sql.Tx = nil
	txn, err = db.Begin()
	if err != nil {
		faultyItems = items
		return
	}

	// These statements' auto close
	stmt := txn.Stmt(statement.InsertIntoStateTable)
	var workingItems []*goque.PriorityItem

	for _, item := range items {
		var pt stateQueue
		err = item.ToObjectFromJSON(&pt)
		if err != nil {
			err = nil
			zap.S().Errorf("Failed to unmarshal item", item)
			continue
		}

		// Create statement
		_, err = stmt.Exec(pt.TimestampMs, pt.DBAssetID, pt.State)
		if err != nil {
			faultyItems = append(faultyItems, item)
			err = nil
			continue
		} else {
			workingItems = append(workingItems, item)
		}
	}

	faultyItems, innerFaultyItems, err2 := CommitWorking(items, faultyItems, txn, workingItems, storeItemsIntoDatabaseState, recursionDepth)
	if err2 != nil {
		return innerFaultyItems, err2
	}

	return faultyItems, err
}
cmd\mqtt-to-postgresql\database.go:980: 980-1025 lines are duplicate of `cmd\mqtt-to-postgresql\database.go:1535-1580` (dupl)
func storeItemsIntoDatabaseScrapCount(items []*goque.PriorityItem, recursionDepth int) (faultyItems []*goque.PriorityItem, err error) {
	if len(items) == 0 {
		faultyItems = []*goque.PriorityItem{}
		return
	}

	var txn *sql.Tx = nil
	txn, err = db.Begin()
	if err != nil {
		faultyItems = items

		return
	}

	// These statements' auto close
	stmt := txn.Stmt(statement.UpdateCountTableScrap)
	var workingItems []*goque.PriorityItem

	for _, item := range items {
		var pt scrapCountQueue
		err = item.ToObjectFromJSON(&pt)
		if err != nil {
			err = nil
			zap.S().Errorf("Failed to unmarshal item", item)
			continue
		}

		// Create statement
		_, err = stmt.Exec(pt.TimestampMs, pt.DBAssetID, pt.Scrap)
		if err != nil {
			faultyItems = append(faultyItems, item)
			err = nil
			continue

		} else {
			workingItems = append(workingItems, item)
		}
	}

	faultyItems, innerFaultyItems, err2 := CommitWorking(items, faultyItems, txn, workingItems, storeItemsIntoDatabaseScrapCount, recursionDepth)
	if err2 != nil {
		return innerFaultyItems, err2
	}

	return faultyItems, err
}
cmd\mqtt-to-postgresql\database.go:1035:2: `if len(faultyItems) > 0` has complex nested blocks (complexity: 22) (nestif)
	if len(faultyItems) > 0 {
	^
cmd\mqtt-to-postgresql\database.go:1052:8: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
				if errx != sql.ErrTxDone {
				   ^
cmd\mqtt-to-postgresql\database.go:1069:8: ineffectual assignment to errx (ineffassign)
							errx = nil
							^
cmd\mqtt-to-postgresql\database.go:1070:8: ineffectual assignment to faultyItems (ineffassign)
							faultyItems, faultyItems, errx = CommitWorking(items, faultyItems, txn, workingItems, fnc, recursionDepth+1)
							^
cmd\mqtt-to-postgresql\database.go:1152: 1152-1206 lines are duplicate of `cmd\mqtt-to-postgresql\database.go:1208-1262` (dupl)
func storeItemsIntoDatabaseProductTag(items []*goque.PriorityItem, recursionDepth int) (faultyItems []*goque.PriorityItem, err error) {
	if len(items) == 0 {
		faultyItems = []*goque.PriorityItem{}
		return
	}

	var txn *sql.Tx = nil
	txn, err = db.Begin()
	if err != nil {
		faultyItems = items

		return
	}

	// These statements' auto close
	stmt := txn.Stmt(statement.InsertIntoProductTagTable)
	var workingItems []*goque.PriorityItem

	for _, item := range items {
		var pt productTagQueue
		err = item.ToObjectFromJSON(&pt)
		if err != nil {
			err = nil
			zap.S().Errorf("Failed to unmarshal item", item)
			continue
		}

		var uid uint32
		var success bool
		uid, err, success = GetUniqueProductID(pt.AID, pt.DBAssetID, 0)
		if err != nil || !success {
			zap.S().Errorf("Stopped writing productTag in Database, uid not found. AID: %s, DBAssetID %d", pt.AID, pt.DBAssetID)
			faultyItems = append(faultyItems, item)
			err = nil
			continue
		}

		// Create statement
		_, err = stmt.Exec(pt.Name, pt.Value, pt.TimestampMs, uid)
		if err != nil {
			faultyItems = append(faultyItems, item)
			err = nil
			continue
		} else {
			workingItems = append(workingItems, item)
		}
	}

	faultyItems, innerFaultyItems, err2 := CommitWorking(items, faultyItems, txn, workingItems, storeItemsIntoDatabaseProductTag, recursionDepth)
	if err2 != nil {
		return innerFaultyItems, err2
	}

	return faultyItems, err
}
cmd\mqtt-to-postgresql\database.go:1208: 1208-1262 lines are duplicate of `cmd\mqtt-to-postgresql\database.go:1152-1206` (dupl)
func storeItemsIntoDatabaseProductTagString(items []*goque.PriorityItem, recursionDepth int) (faultyItems []*goque.PriorityItem, err error) {
	if len(items) == 0 {
		faultyItems = []*goque.PriorityItem{}
		return
	}

	var txn *sql.Tx = nil
	txn, err = db.Begin()
	if err != nil {
		faultyItems = items

		return
	}
	// These statements' auto close
	stmt := txn.Stmt(statement.InsertIntoProductTagStringTable)
	var workingItems []*goque.PriorityItem

	for _, item := range items {
		var pt productTagStringQueue
		err = item.ToObjectFromJSON(&pt)
		if err != nil {
			err = nil
			zap.S().Errorf("Failed to unmarshal item", item)
			continue
		}

		var uid uint32
		var success bool
		uid, err, success = GetUniqueProductID(pt.AID, pt.DBAssetID, 0)
		if err != nil || !success {
			zap.S().Errorf("Stopped writing productTag in Database, uid not found. AID: %s, DBAssetID %d", pt.AID, pt.DBAssetID)
			faultyItems = append(faultyItems, item)
			err = nil
			continue
		}

		// Create statement
		_, err = stmt.Exec(pt.Name, pt.Value, pt.TimestampMs, uid)
		if err != nil {
			faultyItems = append(faultyItems, item)
			err = nil
			continue

		} else {
			workingItems = append(workingItems, item)
		}
	}

	faultyItems, innerFaultyItems, err2 := CommitWorking(items, faultyItems, txn, workingItems, storeItemsIntoDatabaseProductTagString, recursionDepth)
	if err2 != nil {
		return innerFaultyItems, err2
	}

	return faultyItems, err
}
cmd\mqtt-to-postgresql\database.go:1377: 1377-1422 lines are duplicate of `cmd\mqtt-to-postgresql\database.go:1849-1894` (dupl)
func storeItemsIntoDatabaseUniqueProductScrap(items []*goque.PriorityItem, recursionDepth int) (faultyItems []*goque.PriorityItem, err error) {
	if len(items) == 0 {
		faultyItems = []*goque.PriorityItem{}
		return
	}

	var txn *sql.Tx = nil
	txn, err = db.Begin()
	if err != nil {
		faultyItems = items

		return
	}

	// These statements' auto close
	stmt := txn.Stmt(statement.UpdateUniqueProductTableSetIsScrap)
	var workingItems []*goque.PriorityItem

	for _, item := range items {
		var pt scrapUniqueProductQueue
		err = item.ToObjectFromJSON(&pt)
		if err != nil {
			err = nil
			zap.S().Errorf("Failed to unmarshal item", item)
			continue
		}

		// Create statement
		_, err = stmt.Exec(pt.UID, pt.DBAssetID)
		if err != nil {
			faultyItems = append(faultyItems, item)
			err = nil
			continue

		} else {
			workingItems = append(workingItems, item)
		}
	}

	faultyItems, innerFaultyItems, err2 := CommitWorking(items, faultyItems, txn, workingItems, storeItemsIntoDatabaseUniqueProductScrap, recursionDepth)
	if err2 != nil {
		return innerFaultyItems, err2
	}

	return faultyItems, err
}
cmd\mqtt-to-postgresql\database.go:1535: 1535-1580 lines are duplicate of `cmd\mqtt-to-postgresql\database.go:1582-1627` (dupl)
func storeItemsIntoDatabaseStartOrder(items []*goque.PriorityItem, recursionDepth int) (faultyItems []*goque.PriorityItem, err error) {
	if len(items) == 0 {
		faultyItems = []*goque.PriorityItem{}
		return
	}

	var txn *sql.Tx = nil
	txn, err = db.Begin()
	if err != nil {
		faultyItems = items

		return
	}

	// These statements' auto close
	stmt := txn.Stmt(statement.UpdateOrderTableSetBeginTimestamp)
	var workingItems []*goque.PriorityItem

	for _, item := range items {
		var pt startOrderQueue
		err = item.ToObjectFromJSON(&pt)
		if err != nil {
			err = nil
			zap.S().Errorf("Failed to unmarshal item", item)
			continue
		}

		// Create statement
		_, err = stmt.Exec(pt.TimestampMs, pt.OrderName, pt.DBAssetID)
		if err != nil {
			faultyItems = append(faultyItems, item)
			err = nil
			continue

		} else {
			workingItems = append(workingItems, item)
		}
	}

	faultyItems, innerFaultyItems, err2 := CommitWorking(items, faultyItems, txn, workingItems, storeItemsIntoDatabaseStartOrder, recursionDepth)
	if err2 != nil {
		return innerFaultyItems, err2
	}

	return faultyItems, err
}
cmd\mqtt-to-postgresql\database.go:1582: 1582-1627 lines are duplicate of `cmd\mqtt-to-postgresql\database.go:1629-1674` (dupl)
func storeItemsIntoDatabaseEndOrder(items []*goque.PriorityItem, recursionDepth int) (faultyItems []*goque.PriorityItem, err error) {
	if len(items) == 0 {
		faultyItems = []*goque.PriorityItem{}
		return
	}

	var txn *sql.Tx = nil
	txn, err = db.Begin()
	if err != nil {
		faultyItems = items

		return
	}

	// These statements' auto close
	stmt := txn.Stmt(statement.UpdateOrderTableSetEndTimestamp)
	var workingItems []*goque.PriorityItem

	for _, item := range items {
		var pt endOrderQueue
		err = item.ToObjectFromJSON(&pt)
		if err != nil {
			err = nil
			zap.S().Errorf("Failed to unmarshal item", item)
			continue
		}

		// Create statement
		_, err = stmt.Exec(pt.TimestampMs, pt.OrderName, pt.DBAssetID)
		if err != nil {
			faultyItems = append(faultyItems, item)
			err = nil
			continue

		} else {
			workingItems = append(workingItems, item)
		}
	}

	faultyItems, innerFaultyItems, err2 := CommitWorking(items, faultyItems, txn, workingItems, storeItemsIntoDatabaseEndOrder, recursionDepth)
	if err2 != nil {
		return innerFaultyItems, err2
	}

	return faultyItems, err
}
cmd\mqtt-to-postgresql\database.go:1629: 1629-1674 lines are duplicate of `cmd\mqtt-to-postgresql\database.go:935-978` (dupl)
func storeItemsIntoDatabaseAddMaintenanceActivity(items []*goque.PriorityItem, recursionDepth int) (faultyItems []*goque.PriorityItem, err error) {
	if len(items) == 0 {
		faultyItems = []*goque.PriorityItem{}
		return
	}

	var txn *sql.Tx = nil
	txn, err = db.Begin()
	if err != nil {
		faultyItems = items

		return
	}

	// These statements' auto close
	stmt := txn.Stmt(statement.InsertIntoMaintenanceActivities)
	var workingItems []*goque.PriorityItem

	for _, item := range items {
		var pt addMaintenanceActivityQueue
		err = item.ToObjectFromJSON(&pt)
		if err != nil {
			err = nil
			zap.S().Errorf("Failed to unmarshal item", item)
			continue
		}

		// Create statement
		_, err = stmt.Exec(pt.ComponentID, pt.Activity, pt.TimestampMs)
		if err != nil {
			faultyItems = append(faultyItems, item)
			err = nil
			continue

		} else {
			workingItems = append(workingItems, item)
		}
	}

	faultyItems, innerFaultyItems, err2 := CommitWorking(items, faultyItems, txn, workingItems, storeItemsIntoDatabaseAddMaintenanceActivity, recursionDepth)
	if err2 != nil {
		return innerFaultyItems, err2
	}

	return faultyItems, err
}
cmd\mqtt-to-postgresql\database.go:1676:1: cognitive complexity 53 of func `modifyStateInDatabase` is high (> 30) (gocognit)
func modifyStateInDatabase(items []*goque.PriorityItem) (faultyItems []*goque.PriorityItem, err error) {
^
cmd\mqtt-to-postgresql\database.go:1723:3: `if val.Next()` has complex nested blocks (complexity: 13) (nestif)
		if val.Next() {
		^
cmd\mqtt-to-postgresql\database.go:1849: 1849-1894 lines are duplicate of `cmd\mqtt-to-postgresql\database.go:1377-1422` (dupl)
func deleteShiftInDatabaseByAssetIdAndTimestamp(items []*goque.PriorityItem, recursionDepth int) (faultyItems []*goque.PriorityItem, err error) {
	if len(items) == 0 {
		faultyItems = []*goque.PriorityItem{}
		return
	}

	var txn *sql.Tx = nil
	txn, err = db.Begin()
	if err != nil {
		faultyItems = items

		return
	}

	// These statements' auto close
	stmt := txn.Stmt(statement.DeleteFromShiftTableByAssetIDAndBeginTimestamp)
	var workingItems []*goque.PriorityItem

	for _, item := range items {
		var pt deleteShiftByAssetIdAndBeginTimestampQueue
		err = item.ToObjectFromJSON(&pt)
		if err != nil {
			err = nil
			zap.S().Errorf("Failed to unmarshal item", item)
			continue
		}

		// Create statement
		_, err = stmt.Exec(pt.DBAssetID, pt.BeginTimeStampMs)
		if err != nil {
			faultyItems = append(faultyItems, item)
			err = nil
			continue

		} else {
			workingItems = append(workingItems, item)
		}
	}

	faultyItems, innerFaultyItems, err2 := CommitWorking(items, faultyItems, txn, workingItems, deleteShiftInDatabaseByAssetIdAndTimestamp, recursionDepth)
	if err2 != nil {
		return innerFaultyItems, err2
	}

	return faultyItems, err
}
cmd\mqtt-to-postgresql\database.go:1927:3: `if pt.Count > 0` has complex nested blocks (complexity: 14) (nestif)
		if pt.Count > 0 {
		^
cmd\mqtt-to-postgresql\mqtt.go:9:2: `github.com/prometheus/client_golang/prometheus` is not in the allowlist (depguard)
	"github.com/prometheus/client_golang/prometheus"
	^
cmd\mqtt-to-postgresql\mqtt.go:10:2: `github.com/prometheus/client_golang/prometheus/promauto` is not in the allowlist (depguard)
	"github.com/prometheus/client_golang/prometheus/promauto"
	^
cmd\mqtt-to-postgresql\processAddOrder.go:61: 61-99 lines are duplicate of `cmd\mqtt-to-postgresql\processAddParentToChild.go:59-97` (dupl)
func (r AddOrderHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseAddOrder(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processAddOrder.go:73:3: SA4006: this value of `items` is never used (staticcheck)
		items = items[:0]
		^
cmd\mqtt-to-postgresql\processAddOrder.go:109:3: S1006: should use for {} instead of for true {} (gosimple)
		for true {
		^
cmd\mqtt-to-postgresql\processAddOrder.go:159:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == sql.ErrNoRows || !success {
	   ^
cmd\mqtt-to-postgresql\processAddOrder.go:198:2: S1023: redundant `return` statement (gosimple)
	return
	^
cmd\mqtt-to-postgresql\processAddParentToChild.go:59: 59-97 lines are duplicate of `cmd\mqtt-to-postgresql\processAddShift.go:57-95` (dupl)
func (r AddParentToChildHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseAddParentToChild(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processAddParentToChild.go:71:3: SA4006: this value of `items` is never used (staticcheck)
		items = items[:0]
		^
cmd\mqtt-to-postgresql\processAddParentToChild.go:107:3: S1006: should use for {} instead of for true {} (gosimple)
		for true {
		^
cmd\mqtt-to-postgresql\processAddParentToChild.go:134: 134-187 lines are duplicate of `cmd\mqtt-to-postgresql\processModifyState.go:135-188` (dupl)
func (r AddParentToChildHandler) EnqueueMQTT(
	customerID string,
	location string,
	assetID string,
	payload []byte,
	recursionDepth int64) {
	zap.S().Debugf("[AddParentToChildHandler]")
	var parsedPayload addParentToChild

	var json = jsoniter.ConfigCompatibleWithStandardLibrary

	err := json.Unmarshal(payload, &parsedPayload)
	if err != nil {
		zap.S().Errorf("json.Unmarshal failed", err, payload)
		return
	}

	DBassetID, success := GetAssetID(customerID, location, assetID, 0)
	if !success {
		go func() {
			if r.shutdown {
				storedRawMQTTHandler.EnqueueMQTT(
					customerID,
					location,
					assetID,
					payload,
					Prefix.AddOrder,
					recursionDepth+1)
			} else {
				internal.SleepBackedOff(recursionDepth, 10000*time.Nanosecond, 1000*time.Millisecond)
				r.EnqueueMQTT(customerID, location, assetID, payload, recursionDepth+1)
			}
		}()
		return
	}
	newObject := addParentToChildQueue{
		DBAssetID:   DBassetID,
		TimestampMs: parsedPayload.TimestampMs,
		ChildAID:    parsedPayload.ChildAID,
		ParentAID:   parsedPayload.ParentAID,
	}
	if !ValidateStruct(newObject) {
		zap.S().Errorf("Failed to validate struct of type addParentToChildQueue", newObject)
		return
	}

	marshal, err := json.Marshal(newObject)
	if err != nil {
		return
	}

	r.enqueue(marshal, 0)
	return
}
cmd\mqtt-to-postgresql\processAddParentToChild.go:186:2: S1023: redundant `return` statement (gosimple)
	return
	^
cmd\mqtt-to-postgresql\processAddProduct.go:77:3: SA4006: this value of `items` is never used (staticcheck)
		items = items[:0]
		^
cmd\mqtt-to-postgresql\processAddProduct.go:107:3: S1006: should use for {} instead of for true {} (gosimple)
		for true {
		^
cmd\mqtt-to-postgresql\processAddProduct.go:184:2: S1023: redundant `return` statement (gosimple)
	return
	^
cmd\mqtt-to-postgresql\processAddShift.go:1: 1-184 lines are duplicate of `cmd\mqtt-to-postgresql\processEndOrder.go:1-183` (dupl)
package main

import (
	"github.com/beeker1121/goque"
	jsoniter "github.com/json-iterator/go"
	"github.com/united-manufacturing-hub/united-manufacturing-hub/internal"
	"go.uber.org/zap"
	"time"
)

type addShiftQueue struct {
	DBAssetID      uint32
	TimestampMs    uint64
	TimestampMsEnd uint64
}
type addShift struct {
	TimestampMs    uint64 `json:"timestamp_ms"`
	TimestampMsEnd uint64 `json:"timestamp_ms_end"`
}

type AddShiftHandler struct {
	priorityQueue *goque.PriorityQueue
	shutdown      bool
}

func NewAddShiftHandler() (handler *AddShiftHandler) {
	const queuePathDB = "/data/AddShift"
	var priorityQueue *goque.PriorityQueue
	var err error
	priorityQueue, err = SetupQueue(queuePathDB)
	if err != nil {
		zap.S().Errorf("Error setting up remote queue (%s)", queuePathDB, err)
		zap.S().Errorf("err: %s", err)
		ShutdownApplicationGraceful()
		panic("Failed to setup queue, exiting !")
	}

	handler = &AddShiftHandler{
		priorityQueue: priorityQueue,
		shutdown:      false,
	}
	return
}

func (r AddShiftHandler) reportLength() {
	for !r.shutdown {
		time.Sleep(10 * time.Second)
		if r.priorityQueue.Length() > 0 {
			zap.S().Debugf("AddShiftHandler queue length: %d", r.priorityQueue.Length())
		}
	}
}
func (r AddShiftHandler) Setup() {
	go r.reportLength()
	go r.process()
}
func (r AddShiftHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseShift(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}

func (r AddShiftHandler) dequeue() (items []*goque.PriorityItem) {
	if r.priorityQueue.Length() > 0 {
		item, err := r.priorityQueue.Dequeue()
		if err != nil {
			return
		}
		items = append(items, item)

		for true {
			nextItem, err := r.priorityQueue.DequeueByPriority(item.Priority)
			if err != nil {
				break
			}
			items = append(items, nextItem)
		}
	}
	return
}

func (r AddShiftHandler) enqueue(bytes []byte, priority uint8) {
	_, err := r.priorityQueue.Enqueue(priority, bytes)
	if err != nil {
		zap.S().Warnf("Failed to enqueue item", bytes, err)
		return
	}
}

func (r AddShiftHandler) Shutdown() (err error) {
	zap.S().Warnf("[AddShiftHandler] shutting down, Queue length: %d", r.priorityQueue.Length())
	r.shutdown = true

	err = CloseQueue(r.priorityQueue)
	return
}

func (r AddShiftHandler) EnqueueMQTT(
	customerID string,
	location string,
	assetID string,
	payload []byte,
	recursionDepth int64) {
	zap.S().Debugf("[AddShiftHandler]")
	var parsedPayload addShift

	var json = jsoniter.ConfigCompatibleWithStandardLibrary

	err := json.Unmarshal(payload, &parsedPayload)
	if err != nil {
		zap.S().Errorf("json.Unmarshal failed", err, payload)
		return
	}

	DBassetID, success := GetAssetID(customerID, location, assetID, 0)
	if !success {
		go func() {
			if r.shutdown {
				storedRawMQTTHandler.EnqueueMQTT(
					customerID,
					location,
					assetID,
					payload,
					Prefix.AddOrder,
					recursionDepth+1)
			} else {
				internal.SleepBackedOff(recursionDepth, 10000*time.Nanosecond, 1000*time.Millisecond)
				r.EnqueueMQTT(customerID, location, assetID, payload, recursionDepth+1)
			}
		}()
		return
	}
	newObject := addShiftQueue{
		TimestampMs:    parsedPayload.TimestampMs,
		TimestampMsEnd: parsedPayload.TimestampMsEnd,
		DBAssetID:      DBassetID,
	}
	if !ValidateStruct(newObject) {
		zap.S().Errorf("Failed to validate struct of type addShiftQueue", newObject)
		return
	}

	marshal, err := json.Marshal(newObject)
	if err != nil {
		return
	}

	r.enqueue(marshal, 0)
	return
}
cmd\mqtt-to-postgresql\processAddShift.go:57: 57-95 lines are duplicate of `cmd\mqtt-to-postgresql\processDeleteShiftByAssetIdAndBeginTime.go:56-94` (dupl)
func (r AddShiftHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseShift(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processCountData.go:195:9: nilness: impossible condition: nil != nil (govet)
	if err != nil {
	       ^
cmd\mqtt-to-postgresql\processDeleteShiftByAssetIdAndBeginTime.go:1: 1-184 lines are duplicate of `cmd\mqtt-to-postgresql\processDeleteShiftById.go:1-182` (dupl)
package main

import (
	"github.com/beeker1121/goque"
	jsoniter "github.com/json-iterator/go"
	"github.com/united-manufacturing-hub/united-manufacturing-hub/internal"
	"go.uber.org/zap"
	"time"
)

type deleteShiftByAssetIdAndBeginTimestampQueue struct {
	DBAssetID        uint32
	BeginTimeStampMs uint32 `json:"begin_time_stamp"`
}

type deleteShiftByAssetIdAndBeginTimestamp struct {
	BeginTimeStampMs uint32 `json:"begin_time_stamp"`
}

type DeleteShiftByAssetIdAndBeginTimestampHandler struct {
	priorityQueue *goque.PriorityQueue
	shutdown      bool
}

func NewDeleteShiftByAssetIdAndBeginTimestampHandler() (handler *DeleteShiftByAssetIdAndBeginTimestampHandler) {
	const queuePathDB = "/data/DeleteShift"
	var priorityQueue *goque.PriorityQueue
	var err error
	priorityQueue, err = SetupQueue(queuePathDB)
	if err != nil {
		zap.S().Errorf("Error setting up remote queue (%s)", queuePathDB, err)
		zap.S().Errorf("err: %s", err)
		ShutdownApplicationGraceful()
		panic("Failed to setup queue, exiting !")
	}

	handler = &DeleteShiftByAssetIdAndBeginTimestampHandler{
		priorityQueue: priorityQueue,
		shutdown:      false,
	}
	return
}

func (r DeleteShiftByAssetIdAndBeginTimestampHandler) reportLength() {
	for !r.shutdown {
		time.Sleep(10 * time.Second)
		if r.priorityQueue.Length() > 0 {
			zap.S().Debugf("DeleteShiftByAssetIdAndBeginTimestampHandler queue length: %d", r.priorityQueue.Length())
		}
	}
}
func (r DeleteShiftByAssetIdAndBeginTimestampHandler) Setup() {
	go r.reportLength()
	go r.process()
}
func (r DeleteShiftByAssetIdAndBeginTimestampHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := deleteShiftInDatabaseByAssetIdAndTimestamp(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}

func (r DeleteShiftByAssetIdAndBeginTimestampHandler) dequeue() (items []*goque.PriorityItem) {
	if r.priorityQueue.Length() > 0 {
		item, err := r.priorityQueue.Dequeue()
		if err != nil {
			return
		}
		items = append(items, item)

		for true {
			nextItem, err := r.priorityQueue.DequeueByPriority(item.Priority)
			if err != nil {
				break
			}
			items = append(items, nextItem)
		}
	}
	return
}

func (r DeleteShiftByAssetIdAndBeginTimestampHandler) enqueue(bytes []byte, priority uint8) {
	_, err := r.priorityQueue.Enqueue(priority, bytes)
	if err != nil {
		zap.S().Warnf("Failed to enqueue item", bytes, err)
		return
	}
}

func (r DeleteShiftByAssetIdAndBeginTimestampHandler) Shutdown() (err error) {
	zap.S().Warnf(
		"[DeleteShiftByAssetIdAndBeginTimestampHandler] shutting down, Queue length: %d",
		r.priorityQueue.Length())
	r.shutdown = true

	err = CloseQueue(r.priorityQueue)
	return
}

func (r DeleteShiftByAssetIdAndBeginTimestampHandler) EnqueueMQTT(
	customerID string,
	location string,
	assetID string,
	payload []byte,
	recursionDepth int64) {
	zap.S().Debugf("[DeleteShiftByAssetIdAndBeginTimestampHandler]")
	var parsedPayload deleteShiftByAssetIdAndBeginTimestamp

	var json = jsoniter.ConfigCompatibleWithStandardLibrary

	err := json.Unmarshal(payload, &parsedPayload)
	if err != nil {
		zap.S().Errorf("json.Unmarshal failed", err, payload)
		return
	}

	DBassetID, success := GetAssetID(customerID, location, assetID, 0)
	if !success {
		go func() {
			if r.shutdown {
				storedRawMQTTHandler.EnqueueMQTT(
					customerID,
					location,
					assetID,
					payload,
					Prefix.AddOrder,
					recursionDepth+1)
			} else {
				internal.SleepBackedOff(recursionDepth, 10000*time.Nanosecond, 1000*time.Millisecond)
				r.EnqueueMQTT(customerID, location, assetID, payload, recursionDepth+1)
			}
		}()
		return
	}
	newObject := deleteShiftByAssetIdAndBeginTimestampQueue{
		DBAssetID:        DBassetID,
		BeginTimeStampMs: parsedPayload.BeginTimeStampMs,
	}
	if !ValidateStruct(newObject) {
		zap.S().Errorf("Failed to validate struct of type deleteShiftByAssetIdAndBeginTimestampQueue", newObject)
		return
	}

	marshal, err := json.Marshal(newObject)
	if err != nil {
		return
	}

	r.enqueue(marshal, 0)
	return
}
cmd\mqtt-to-postgresql\processDeleteShiftByAssetIdAndBeginTime.go:56: 56-94 lines are duplicate of `cmd\mqtt-to-postgresql\processDeleteShiftById.go:56-94` (dupl)
func (r DeleteShiftByAssetIdAndBeginTimestampHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := deleteShiftInDatabaseByAssetIdAndTimestamp(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processDeleteShiftById.go:1: 1-182 lines are duplicate of `cmd\mqtt-to-postgresql\processDeleteShiftByAssetIdAndBeginTime.go:1-184` (dupl)
package main

import (
	"github.com/beeker1121/goque"
	jsoniter "github.com/json-iterator/go"
	"github.com/united-manufacturing-hub/united-manufacturing-hub/internal"
	"go.uber.org/zap"
	"time"
)

type deleteShiftByIdQueue struct {
	DBAssetID uint32
	ShiftId   uint32 `json:"shift_id"`
}

type deleteShiftById struct {
	ShiftId uint32 `json:"shift_id"`
}

type DeleteShiftByIdHandler struct {
	priorityQueue *goque.PriorityQueue
	shutdown      bool
}

func NewDeleteShiftByIdHandler() (handler *DeleteShiftByIdHandler) {
	const queuePathDB = "/data/DeleteShiftById"
	var priorityQueue *goque.PriorityQueue
	var err error
	priorityQueue, err = SetupQueue(queuePathDB)
	if err != nil {
		zap.S().Errorf("Error setting up remote queue (%s)", queuePathDB, err)
		zap.S().Errorf("err: %s", err)
		ShutdownApplicationGraceful()
		panic("Failed to setup queue, exiting !")
	}

	handler = &DeleteShiftByIdHandler{
		priorityQueue: priorityQueue,
		shutdown:      false,
	}
	return
}

func (r DeleteShiftByIdHandler) reportLength() {
	for !r.shutdown {
		time.Sleep(10 * time.Second)
		if r.priorityQueue.Length() > 0 {
			zap.S().Debugf("DeleteShiftByIdHandler queue length: %d", r.priorityQueue.Length())
		}
	}
}
func (r DeleteShiftByIdHandler) Setup() {
	go r.reportLength()
	go r.process()
}
func (r DeleteShiftByIdHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := deleteShiftInDatabaseById(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}

func (r DeleteShiftByIdHandler) dequeue() (items []*goque.PriorityItem) {
	if r.priorityQueue.Length() > 0 {
		item, err := r.priorityQueue.Dequeue()
		if err != nil {
			return
		}
		items = append(items, item)

		for true {
			nextItem, err := r.priorityQueue.DequeueByPriority(item.Priority)
			if err != nil {
				break
			}
			items = append(items, nextItem)
		}
	}
	return
}

func (r DeleteShiftByIdHandler) enqueue(bytes []byte, priority uint8) {
	_, err := r.priorityQueue.Enqueue(priority, bytes)
	if err != nil {
		zap.S().Warnf("Failed to enqueue item", bytes, err)
		return
	}
}

func (r DeleteShiftByIdHandler) Shutdown() (err error) {
	zap.S().Warnf("[DeleteShiftByIdHandler] shutting down, Queue length: %d", r.priorityQueue.Length())
	r.shutdown = true

	err = CloseQueue(r.priorityQueue)
	return
}

func (r DeleteShiftByIdHandler) EnqueueMQTT(
	customerID string,
	location string,
	assetID string,
	payload []byte,
	recursionDepth int64) {
	zap.S().Debugf("[DeleteShiftByIdHandler]")
	var parsedPayload deleteShiftById

	var json = jsoniter.ConfigCompatibleWithStandardLibrary

	err := json.Unmarshal(payload, &parsedPayload)
	if err != nil {
		zap.S().Errorf("json.Unmarshal failed", err, payload)
		return
	}

	DBassetID, success := GetAssetID(customerID, location, assetID, 0)
	if !success {
		go func() {
			if r.shutdown {
				storedRawMQTTHandler.EnqueueMQTT(
					customerID,
					location,
					assetID,
					payload,
					Prefix.AddOrder,
					recursionDepth+1)
			} else {
				internal.SleepBackedOff(recursionDepth, 10000*time.Nanosecond, 1000*time.Millisecond)
				r.EnqueueMQTT(customerID, location, assetID, payload, recursionDepth+1)
			}
		}()
		return
	}
	newObject := deleteShiftByIdQueue{
		DBAssetID: DBassetID,
		ShiftId:   parsedPayload.ShiftId,
	}
	if !ValidateStruct(newObject) {
		zap.S().Errorf("Failed to validate struct of type deleteShiftByIdQueue", newObject)
		return
	}

	marshal, err := json.Marshal(newObject)
	if err != nil {
		return
	}

	r.enqueue(marshal, 0)
	return
}
cmd\mqtt-to-postgresql\processDeleteShiftById.go:56: 56-94 lines are duplicate of `cmd\mqtt-to-postgresql\processEndOrder.go:56-94` (dupl)
func (r DeleteShiftByIdHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := deleteShiftInDatabaseById(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processEndOrder.go:1: 1-183 lines are duplicate of `cmd\mqtt-to-postgresql\processScrapCount.go:1-185` (dupl)
package main

import (
	"github.com/beeker1121/goque"
	jsoniter "github.com/json-iterator/go"
	"github.com/united-manufacturing-hub/united-manufacturing-hub/internal"
	"go.uber.org/zap"
	"time"
)

type endOrderQueue struct {
	OrderName   string
	TimestampMs uint64
	DBAssetID   uint32
}
type endOrder struct {
	OrderName   string `json:"order_id"`
	TimestampMs uint64 `json:"timestamp_ms"`
}
type EndOrderHandler struct {
	priorityQueue *goque.PriorityQueue
	shutdown      bool
}

func NewEndOrderHandler() (handler *EndOrderHandler) {
	const queuePathDB = "/data/EndOrder"
	var priorityQueue *goque.PriorityQueue
	var err error
	priorityQueue, err = SetupQueue(queuePathDB)
	if err != nil {
		zap.S().Errorf("Error setting up remote queue (%s)", queuePathDB, err)
		zap.S().Errorf("err: %s", err)
		ShutdownApplicationGraceful()
		panic("Failed to setup queue, exiting !")
	}

	handler = &EndOrderHandler{
		priorityQueue: priorityQueue,
		shutdown:      false,
	}
	return
}

func (r EndOrderHandler) reportLength() {
	for !r.shutdown {
		time.Sleep(10 * time.Second)
		if r.priorityQueue.Length() > 0 {
			zap.S().Debugf("EndOrderHandler queue length: %d", r.priorityQueue.Length())
		}
	}
}
func (r EndOrderHandler) Setup() {
	go r.reportLength()
	go r.process()
}
func (r EndOrderHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseEndOrder(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}

func (r EndOrderHandler) dequeue() (items []*goque.PriorityItem) {
	if r.priorityQueue.Length() > 0 {
		item, err := r.priorityQueue.Dequeue()
		if err != nil {
			return
		}
		items = append(items, item)

		for true {
			nextItem, err := r.priorityQueue.DequeueByPriority(item.Priority)
			if err != nil {
				break
			}
			items = append(items, nextItem)
		}
	}
	return
}

func (r EndOrderHandler) enqueue(bytes []byte, priority uint8) {
	_, err := r.priorityQueue.Enqueue(priority, bytes)
	if err != nil {
		zap.S().Warnf("Failed to enqueue item", bytes, err)
		return
	}
}

func (r EndOrderHandler) Shutdown() (err error) {
	zap.S().Warnf("[EndOrderHandler] shutting down, Queue length: %d", r.priorityQueue.Length())
	r.shutdown = true

	err = CloseQueue(r.priorityQueue)
	return
}

func (r EndOrderHandler) EnqueueMQTT(
	customerID string,
	location string,
	assetID string,
	payload []byte,
	recursionDepth int64) {
	zap.S().Debugf("[EndOrderHandler]")
	var parsedPayload endOrder

	var json = jsoniter.ConfigCompatibleWithStandardLibrary

	err := json.Unmarshal(payload, &parsedPayload)
	if err != nil {
		zap.S().Errorf("json.Unmarshal failed", err, payload)
		return
	}

	DBassetID, success := GetAssetID(customerID, location, assetID, 0)
	if !success {
		go func() {
			if r.shutdown {
				storedRawMQTTHandler.EnqueueMQTT(
					customerID,
					location,
					assetID,
					payload,
					Prefix.AddOrder,
					recursionDepth+1)
			} else {
				internal.SleepBackedOff(recursionDepth, 10000*time.Nanosecond, 1000*time.Millisecond)
				r.EnqueueMQTT(customerID, location, assetID, payload, recursionDepth+1)
			}
		}()
		return
	}
	newObject := endOrderQueue{
		TimestampMs: parsedPayload.TimestampMs,
		OrderName:   parsedPayload.OrderName,
		DBAssetID:   DBassetID,
	}
	if !ValidateStruct(newObject) {
		zap.S().Errorf("Failed to validate struct of type endOrderQueue", newObject)
		return
	}

	marshal, err := json.Marshal(newObject)
	if err != nil {
		return
	}

	r.enqueue(marshal, 0)
	return
}
cmd\mqtt-to-postgresql\processEndOrder.go:56: 56-94 lines are duplicate of `cmd\mqtt-to-postgresql\processMaintenanceActivity.go:60-98` (dupl)
func (r EndOrderHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseEndOrder(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processMaintenanceActivity.go:60: 60-98 lines are duplicate of `cmd\mqtt-to-postgresql\processModifyProducedPiece.go:62-100` (dupl)
func (r MaintenanceActivityHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseAddMaintenanceActivity(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processModifyProducedPiece.go:62: 62-100 lines are duplicate of `cmd\mqtt-to-postgresql\processProductTag.go:61-100` (dupl)
func (r ModifyProducedPieceHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := modifyInDatabaseModifyCountAndScrap(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processModifyState.go:60: 60-98 lines are duplicate of `cmd\mqtt-to-postgresql\processValueString.go:54-92` (dupl)
func (r ModifyStateHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := modifyStateInDatabase(items)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processModifyState.go:135: 135-188 lines are duplicate of `cmd\mqtt-to-postgresql\processAddParentToChild.go:134-187` (dupl)
func (r ModifyStateHandler) EnqueueMQTT(
	customerID string,
	location string,
	assetID string,
	payload []byte,
	recursionDepth int64) {
	zap.S().Debugf("[ModifyStateHandler]")
	var parsedPayload modifyState

	var json = jsoniter.ConfigCompatibleWithStandardLibrary

	err := json.Unmarshal(payload, &parsedPayload)
	if err != nil {
		zap.S().Errorf("json.Unmarshal failed", err, payload)
		return
	}

	DBassetID, success := GetAssetID(customerID, location, assetID, 0)
	if !success {
		go func() {
			if r.shutdown {
				storedRawMQTTHandler.EnqueueMQTT(
					customerID,
					location,
					assetID,
					payload,
					Prefix.AddOrder,
					recursionDepth+1)
			} else {
				internal.SleepBackedOff(recursionDepth, 10000*time.Nanosecond, 1000*time.Millisecond)
				r.EnqueueMQTT(customerID, location, assetID, payload, recursionDepth+1)
			}
		}()
		return
	}
	newObject := modifyStateQueue{
		DBAssetID:        DBassetID,
		StartTimeStampMs: parsedPayload.StartTimeStampMs,
		EndTimeStampMs:   parsedPayload.EndTimeStampMs,
		NewState:         parsedPayload.NewState,
	}
	if !ValidateStruct(newObject) {
		zap.S().Errorf("Failed to validate struct of type modifyStateQueue", newObject)
		return
	}

	marshal, err := json.Marshal(newObject)
	if err != nil {
		return
	}

	r.enqueue(marshal, 0)
	return
}
cmd\mqtt-to-postgresql\processProductTag.go:1: 1-189 lines are duplicate of `cmd\mqtt-to-postgresql\processProductTagString.go:1-191` (dupl)
package main

import (
	"github.com/beeker1121/goque"
	jsoniter "github.com/json-iterator/go"
	"github.com/united-manufacturing-hub/united-manufacturing-hub/internal"
	"go.uber.org/zap"
	"time"
)

type productTagQueue struct {
	AID         string  `json:"AID"`
	Name        string  `json:"name"`
	TimestampMs uint64  `json:"timestamp_ms"`
	Value       float64 `json:"value"`
	DBAssetID   uint32
}

type productTag struct {
	AID         string  `json:"AID"`
	Name        string  `json:"name"`
	TimestampMs uint64  `json:"timestamp_ms"`
	Value       float64 `json:"value"`
}
type ProductTagHandler struct {
	priorityQueue *goque.PriorityQueue
	shutdown      bool
}

func NewProductTagHandler() (handler *ProductTagHandler) {
	const queuePathDB = "/data/ProductTag"
	var priorityQueue *goque.PriorityQueue
	var err error
	priorityQueue, err = SetupQueue(queuePathDB)
	if err != nil {
		zap.S().Errorf("Error setting up remote queue (%s)", queuePathDB, err)
		zap.S().Errorf("err: %s", err)
		ShutdownApplicationGraceful()
		panic("Failed to setup queue, exiting !")
	}

	handler = &ProductTagHandler{
		priorityQueue: priorityQueue,
		shutdown:      false,
	}
	return
}

func (r ProductTagHandler) reportLength() {
	for !r.shutdown {
		time.Sleep(10 * time.Second)
		if r.priorityQueue.Length() > 0 {
			zap.S().Debugf("ProductTagHandler queue length: %d", r.priorityQueue.Length())
		}
	}
}
func (r ProductTagHandler) Setup() {
	go r.reportLength()
	go r.process()
}
func (r ProductTagHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}

		faultyItems, err := storeItemsIntoDatabaseProductTag(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}

func (r ProductTagHandler) dequeue() (items []*goque.PriorityItem) {
	if r.priorityQueue.Length() > 0 {
		item, err := r.priorityQueue.Dequeue()
		if err != nil {
			return
		}
		items = append(items, item)

		for true {
			nextItem, err := r.priorityQueue.DequeueByPriority(item.Priority)
			if err != nil {
				break
			}
			items = append(items, nextItem)
		}
	}
	return
}
func (r ProductTagHandler) enqueue(bytes []byte, priority uint8) {
	_, err := r.priorityQueue.Enqueue(priority, bytes)
	if err != nil {
		zap.S().Warnf("Failed to enqueue item", bytes, err)
		return
	}
}

func (r ProductTagHandler) Shutdown() (err error) {
	zap.S().Warnf("[ProductTagHandler] shutting down, Queue length: %d", r.priorityQueue.Length())
	r.shutdown = true

	err = CloseQueue(r.priorityQueue)
	return
}

func (r ProductTagHandler) EnqueueMQTT(
	customerID string,
	location string,
	assetID string,
	payload []byte,
	recursionDepth int64) {
	zap.S().Debugf("[ProductTagHandler]")
	var parsedPayload productTag

	var json = jsoniter.ConfigCompatibleWithStandardLibrary

	err := json.Unmarshal(payload, &parsedPayload)
	if err != nil {
		zap.S().Errorf("json.Unmarshal failed", err, payload)
		return
	}

	DBassetID, success := GetAssetID(customerID, location, assetID, 0)
	if !success {
		go func() {
			if r.shutdown {
				storedRawMQTTHandler.EnqueueMQTT(
					customerID,
					location,
					assetID,
					payload,
					Prefix.AddOrder,
					recursionDepth+1)
			} else {
				internal.SleepBackedOff(recursionDepth, 10000*time.Nanosecond, 1000*time.Millisecond)
				r.EnqueueMQTT(customerID, location, assetID, payload, recursionDepth+1)
			}
		}()
		return
	}
	newObject := productTagQueue{
		DBAssetID:   DBassetID,
		TimestampMs: parsedPayload.TimestampMs,
		AID:         parsedPayload.AID,
		Name:        parsedPayload.Name,
		Value:       parsedPayload.Value,
	}
	if !ValidateStruct(newObject) {
		zap.S().Errorf("Failed to validate struct of type productTagQueue", newObject)
		return
	}

	marshal, err := json.Marshal(newObject)
	if err != nil {
		return
	}
	r.enqueue(marshal, 0)
	return
}
cmd\mqtt-to-postgresql\processProductTag.go:61: 61-100 lines are duplicate of `cmd\mqtt-to-postgresql\processProductTagString.go:62-100` (dupl)
func (r ProductTagHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}

		faultyItems, err := storeItemsIntoDatabaseProductTag(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processProductTagString.go:1: 1-191 lines are duplicate of `cmd\mqtt-to-postgresql\processProductTag.go:1-189` (dupl)
package main

import (
	"github.com/beeker1121/goque"
	jsoniter "github.com/json-iterator/go"
	"github.com/united-manufacturing-hub/united-manufacturing-hub/internal"
	"go.uber.org/zap"
	"time"
)

type productTagStringQueue struct {
	AID         string `json:"AID"`
	Name        string `json:"name"`
	Value       string `json:"value"`
	TimestampMs uint64 `json:"timestamp_ms"`
	DBAssetID   uint32
}

type productTagString struct {
	AID         string `json:"AID"`
	Name        string `json:"name"`
	Value       string `json:"value"`
	TimestampMs uint64 `json:"timestamp_ms"`
}

type ProductTagStringHandler struct {
	priorityQueue *goque.PriorityQueue
	shutdown      bool
}

func NewProductTagStringHandler() (handler *ProductTagStringHandler) {
	const queuePathDB = "/data/ProductTagString"
	var priorityQueue *goque.PriorityQueue
	var err error
	priorityQueue, err = SetupQueue(queuePathDB)
	if err != nil {
		zap.S().Errorf("Error setting up remote queue (%s)", queuePathDB, err)
		zap.S().Errorf("err: %s", err)
		ShutdownApplicationGraceful()
		panic("Failed to setup queue, exiting !")
	}

	handler = &ProductTagStringHandler{
		priorityQueue: priorityQueue,
		shutdown:      false,
	}
	return
}

func (r ProductTagStringHandler) reportLength() {
	for !r.shutdown {
		time.Sleep(10 * time.Second)
		if r.priorityQueue.Length() > 0 {
			zap.S().Debugf("ProductTagStringHandler queue length: %d", r.priorityQueue.Length())
		}
	}
}
func (r ProductTagStringHandler) Setup() {
	go r.reportLength()
	go r.process()
}
func (r ProductTagStringHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseProductTagString(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}

func (r ProductTagStringHandler) dequeue() (items []*goque.PriorityItem) {
	if r.priorityQueue.Length() > 0 {
		item, err := r.priorityQueue.Dequeue()
		if err != nil {
			return
		}
		items = append(items, item)

		for true {
			nextItem, err := r.priorityQueue.DequeueByPriority(item.Priority)
			if err != nil {
				break
			}
			items = append(items, nextItem)
		}
	}
	return
}

func (r ProductTagStringHandler) enqueue(bytes []byte, priority uint8) {
	_, err := r.priorityQueue.Enqueue(priority, bytes)
	if err != nil {
		zap.S().Warnf("Failed to enqueue item", bytes, err)
		return
	}
}

func (r ProductTagStringHandler) Shutdown() (err error) {
	zap.S().Warnf("[ProductTagStringHandler] shutting down, Queue length: %d", r.priorityQueue.Length())
	r.shutdown = true

	err = CloseQueue(r.priorityQueue)
	return
}

func (r ProductTagStringHandler) EnqueueMQTT(
	customerID string,
	location string,
	assetID string,
	payload []byte,
	recursionDepth int64) {
	zap.S().Debugf("[ProductTagStringHandler]")
	var parsedPayload productTagString

	var json = jsoniter.ConfigCompatibleWithStandardLibrary

	err := json.Unmarshal(payload, &parsedPayload)
	if err != nil {
		zap.S().Errorf("json.Unmarshal failed", err, payload)
		return
	}

	DBassetID, success := GetAssetID(customerID, location, assetID, 0)
	if !success {
		go func() {
			if r.shutdown {
				storedRawMQTTHandler.EnqueueMQTT(
					customerID,
					location,
					assetID,
					payload,
					Prefix.AddOrder,
					recursionDepth+1)
			} else {
				internal.SleepBackedOff(recursionDepth, 10000*time.Nanosecond, 1000*time.Millisecond)
				r.EnqueueMQTT(customerID, location, assetID, payload, recursionDepth+1)
			}
		}()
		return
	}
	newObject := productTagStringQueue{
		DBAssetID:   DBassetID,
		TimestampMs: parsedPayload.TimestampMs,
		AID:         parsedPayload.AID,
		Name:        parsedPayload.Name,
		Value:       parsedPayload.Value,
	}
	if !ValidateStruct(newObject) {
		zap.S().Errorf("Failed to validate struct of type productTagStringQueue", newObject)
		return
	}

	marshal, err := json.Marshal(newObject)
	if err != nil {
		return
	}

	r.enqueue(marshal, 0)
	return
}
cmd\mqtt-to-postgresql\processProductTagString.go:62: 62-100 lines are duplicate of `cmd\mqtt-to-postgresql\processRecommendationData.go:62-100` (dupl)
func (r ProductTagStringHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseProductTagString(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processRecommendationData.go:62: 62-100 lines are duplicate of `cmd\mqtt-to-postgresql\processScrapCount.go:57-95` (dupl)
func (r RecommendationDataHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseRecommendation(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processScrapCount.go:1: 1-185 lines are duplicate of `cmd\mqtt-to-postgresql\processStartOrder.go:1-183` (dupl)
package main

import (
	"github.com/beeker1121/goque"
	jsoniter "github.com/json-iterator/go"
	"github.com/united-manufacturing-hub/united-manufacturing-hub/internal"
	"go.uber.org/zap"
	"time"
)

type scrapCountQueue struct {
	DBAssetID   uint32
	Scrap       uint32
	TimestampMs uint64
}
type scrapCount struct {
	Scrap       uint32 `json:"scrap"`
	TimestampMs uint64 `json:"timestamp_ms"`
}

type ScrapCountHandler struct {
	priorityQueue *goque.PriorityQueue
	shutdown      bool
}

func NewScrapCountHandler() (handler *ScrapCountHandler) {
	const queuePathDB = "/data/ScrapCount"
	var priorityQueue *goque.PriorityQueue
	var err error
	priorityQueue, err = SetupQueue(queuePathDB)
	if err != nil {
		zap.S().Errorf("Error setting up remote queue (%s)", queuePathDB, err)
		zap.S().Errorf("err: %s", err)
		ShutdownApplicationGraceful()
		panic("Failed to setup queue, exiting !")
	}

	handler = &ScrapCountHandler{
		priorityQueue: priorityQueue,
		shutdown:      false,
	}
	return
}

func (r ScrapCountHandler) reportLength() {
	for !r.shutdown {
		time.Sleep(10 * time.Second)
		if r.priorityQueue.Length() > 0 {
			zap.S().Debugf("ScrapCountHandler queue length: %d", r.priorityQueue.Length())
		}
	}
}
func (r ScrapCountHandler) Setup() {
	go r.reportLength()
	go r.process()
}
func (r ScrapCountHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseScrapCount(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}

func (r ScrapCountHandler) dequeue() (items []*goque.PriorityItem) {
	if r.priorityQueue.Length() > 0 {
		item, err := r.priorityQueue.Dequeue()
		if err != nil {
			return
		}
		items = append(items, item)

		for true {
			nextItem, err := r.priorityQueue.DequeueByPriority(item.Priority)
			if err != nil {
				break
			}
			items = append(items, nextItem)
		}
	}
	return
}

func (r ScrapCountHandler) enqueue(bytes []byte, priority uint8) {
	_, err := r.priorityQueue.Enqueue(priority, bytes)
	if err != nil {
		zap.S().Warnf("Failed to enqueue item", bytes, err)
		return
	}
}

func (r ScrapCountHandler) Shutdown() (err error) {
	zap.S().Warnf("[ScrapCountHandler] shutting down, Queue length: %d", r.priorityQueue.Length())
	r.shutdown = true

	err = CloseQueue(r.priorityQueue)
	return
}

func (r ScrapCountHandler) EnqueueMQTT(
	customerID string,
	location string,
	assetID string,
	payload []byte,
	recursionDepth int64) {
	zap.S().Debugf("[ScrapCountHandler]")
	var parsedPayload scrapCount

	var json = jsoniter.ConfigCompatibleWithStandardLibrary

	err := json.Unmarshal(payload, &parsedPayload)
	if err != nil {
		zap.S().Errorf("json.Unmarshal failed", err, payload)
		return
	}

	DBassetID, success := GetAssetID(customerID, location, assetID, 0)
	if !success {
		go func() {
			if r.shutdown {
				storedRawMQTTHandler.EnqueueMQTT(
					customerID,
					location,
					assetID,
					payload,
					Prefix.AddOrder,
					recursionDepth+1)
			} else {
				internal.SleepBackedOff(recursionDepth, 10000*time.Nanosecond, 1000*time.Millisecond)
				r.EnqueueMQTT(customerID, location, assetID, payload, recursionDepth+1)
			}
		}()
		return
	}

	newObject := scrapCountQueue{
		TimestampMs: parsedPayload.TimestampMs,
		Scrap:       parsedPayload.Scrap,
		DBAssetID:   DBassetID,
	}
	if !ValidateStruct(newObject) {
		zap.S().Errorf("Failed to validate struct of type scrapCountQueue", newObject)
		return
	}

	marshal, err := json.Marshal(newObject)
	if err != nil {
		return
	}

	r.enqueue(marshal, 0)
	return
}
cmd\mqtt-to-postgresql\processScrapCount.go:57: 57-95 lines are duplicate of `cmd\mqtt-to-postgresql\processScrapUniqueProduct.go:55-93` (dupl)
func (r ScrapCountHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseScrapCount(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processScrapUniqueProduct.go:55: 55-93 lines are duplicate of `cmd\mqtt-to-postgresql\processStartOrder.go:56-94` (dupl)
func (r ScrapUniqueProductHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseUniqueProductScrap(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processStartOrder.go:1: 1-183 lines are duplicate of `cmd\mqtt-to-postgresql\processState.go:1-180` (dupl)
package main

import (
	"github.com/beeker1121/goque"
	jsoniter "github.com/json-iterator/go"
	"github.com/united-manufacturing-hub/united-manufacturing-hub/internal"
	"go.uber.org/zap"
	"time"
)

type startOrderQueue struct {
	OrderName   string
	TimestampMs uint64
	DBAssetID   uint32
}
type startOrder struct {
	OrderName   string `json:"order_id"`
	TimestampMs uint64 `json:"timestamp_ms"`
}
type StartOrderHandler struct {
	priorityQueue *goque.PriorityQueue
	shutdown      bool
}

func NewStartOrderHandler() (handler *StartOrderHandler) {
	const queuePathDB = "/data/StartOrder"
	var priorityQueue *goque.PriorityQueue
	var err error
	priorityQueue, err = SetupQueue(queuePathDB)
	if err != nil {
		zap.S().Errorf("Error setting up remote queue (%s)", queuePathDB, err)
		zap.S().Errorf("err: %s", err)
		ShutdownApplicationGraceful()
		panic("Failed to setup queue, exiting !")
	}

	handler = &StartOrderHandler{
		priorityQueue: priorityQueue,
		shutdown:      false,
	}
	return
}

func (r StartOrderHandler) reportLength() {
	for !r.shutdown {
		time.Sleep(10 * time.Second)
		if r.priorityQueue.Length() > 0 {
			zap.S().Debugf("StartOrderHandler queue length: %d", r.priorityQueue.Length())
		}
	}
}
func (r StartOrderHandler) Setup() {
	go r.reportLength()
	go r.process()
}
func (r StartOrderHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseStartOrder(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}

func (r StartOrderHandler) dequeue() (items []*goque.PriorityItem) {
	if r.priorityQueue.Length() > 0 {
		item, err := r.priorityQueue.Dequeue()
		if err != nil {
			return
		}
		items = append(items, item)

		for true {
			nextItem, err := r.priorityQueue.DequeueByPriority(item.Priority)
			if err != nil {
				break
			}
			items = append(items, nextItem)
		}
	}
	return
}

func (r StartOrderHandler) enqueue(bytes []byte, priority uint8) {
	_, err := r.priorityQueue.Enqueue(priority, bytes)
	if err != nil {
		zap.S().Warnf("Failed to enqueue item", bytes, err)
		return
	}
}

func (r StartOrderHandler) Shutdown() (err error) {
	zap.S().Warnf("[StartOrderHandler] shutting down, Queue length: %d", r.priorityQueue.Length())
	r.shutdown = true

	err = CloseQueue(r.priorityQueue)
	return
}

func (r StartOrderHandler) EnqueueMQTT(
	customerID string,
	location string,
	assetID string,
	payload []byte,
	recursionDepth int64) {
	zap.S().Debugf("[StartOrderHandler]")
	var parsedPayload startOrder

	var json = jsoniter.ConfigCompatibleWithStandardLibrary

	err := json.Unmarshal(payload, &parsedPayload)
	if err != nil {
		zap.S().Errorf("json.Unmarshal failed", err, payload)
		return
	}

	DBassetID, success := GetAssetID(customerID, location, assetID, 0)
	if !success {
		go func() {
			if r.shutdown {
				storedRawMQTTHandler.EnqueueMQTT(
					customerID,
					location,
					assetID,
					payload,
					Prefix.AddOrder,
					recursionDepth+1)
			} else {
				internal.SleepBackedOff(recursionDepth, 10000*time.Nanosecond, 1000*time.Millisecond)
				r.EnqueueMQTT(customerID, location, assetID, payload, recursionDepth+1)
			}
		}()
		return
	}
	newObject := startOrderQueue{
		TimestampMs: parsedPayload.TimestampMs,
		OrderName:   parsedPayload.OrderName,
		DBAssetID:   DBassetID,
	}
	if !ValidateStruct(newObject) {
		zap.S().Errorf("Failed to validate struct of type startOrderQueue", newObject)
		return
	}

	marshal, err := json.Marshal(newObject)
	if err != nil {
		return
	}

	r.enqueue(marshal, 0)
	return
}
cmd\mqtt-to-postgresql\processStartOrder.go:56: 56-94 lines are duplicate of `cmd\mqtt-to-postgresql\processState.go:57-95` (dupl)
func (r StartOrderHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseStartOrder(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processState.go:1: 1-180 lines are duplicate of `cmd\mqtt-to-postgresql\processAddShift.go:1-184` (dupl)
package main

import (
	"github.com/beeker1121/goque"
	jsoniter "github.com/json-iterator/go"
	"github.com/united-manufacturing-hub/united-manufacturing-hub/internal"
	"go.uber.org/zap"
	"time"
)

type stateQueue struct {
	DBAssetID   uint32
	State       uint32
	TimestampMs uint64
}
type state struct {
	State       uint32 `json:"state"`
	TimestampMs uint64 `json:"timestamp_ms"`
}

type StateHandler struct {
	priorityQueue *goque.PriorityQueue
	shutdown      bool
}

func NewStateHandler() (handler *StateHandler) {
	const queuePathDB = "/data/State"
	var priorityQueue *goque.PriorityQueue
	var err error
	priorityQueue, err = SetupQueue(queuePathDB)
	if err != nil {
		zap.S().Errorf("Error setting up remote queue (%s)", queuePathDB, err)
		zap.S().Errorf("err: %s", err)
		ShutdownApplicationGraceful()
		panic("Failed to setup queue, exiting !")
	}

	handler = &StateHandler{
		priorityQueue: priorityQueue,
		shutdown:      false,
	}
	return
}

func (r StateHandler) reportLength() {
	for !r.shutdown {
		time.Sleep(10 * time.Second)
		if r.priorityQueue.Length() > 0 {
			zap.S().Debugf("StateHandler queue length: %d", r.priorityQueue.Length())
		}
	}
}
func (r StateHandler) Setup() {
	go r.reportLength()
	go r.process()
}
func (r StateHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseState(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}

func (r StateHandler) dequeue() (items []*goque.PriorityItem) {
	if r.priorityQueue.Length() > 0 {
		item, err := r.priorityQueue.Dequeue()
		if err != nil {
			return
		}
		items = append(items, item)

		for true {
			nextItem, err := r.priorityQueue.DequeueByPriority(item.Priority)
			if err != nil {
				break
			}
			items = append(items, nextItem)
		}
	}
	return
}
func (r StateHandler) enqueue(bytes []byte, priority uint8) {
	_, err := r.priorityQueue.Enqueue(priority, bytes)
	if err != nil {
		zap.S().Warnf("Failed to enqueue item", bytes, err)
		return
	}
}

func (r StateHandler) Shutdown() (err error) {
	zap.S().Warnf("[StateHandler] shutting down, Queue length: %d", r.priorityQueue.Length())
	r.shutdown = true

	err = CloseQueue(r.priorityQueue)
	return
}

func (r StateHandler) EnqueueMQTT(
	customerID string,
	location string,
	assetID string,
	payload []byte,
	recursionDepth int64) {
	zap.S().Debugf("[StateHandler]")
	var parsedPayload state
	var json = jsoniter.ConfigCompatibleWithStandardLibrary

	err := json.Unmarshal(payload, &parsedPayload)
	if err != nil {
		zap.S().Errorf("json.Unmarshal failed", err, payload)
		return
	}
	DBassetID, success := GetAssetID(customerID, location, assetID, 0)
	if !success {
		go func() {
			if r.shutdown {
				storedRawMQTTHandler.EnqueueMQTT(
					customerID,
					location,
					assetID,
					payload,
					Prefix.AddOrder,
					recursionDepth+1)
			} else {
				internal.SleepBackedOff(recursionDepth, 10000*time.Nanosecond, 1000*time.Millisecond)
				r.EnqueueMQTT(customerID, location, assetID, payload, recursionDepth+1)
			}
		}()
		return
	}
	newObject := stateQueue{
		TimestampMs: parsedPayload.TimestampMs,
		State:       parsedPayload.State,
		DBAssetID:   DBassetID,
	}
	if !ValidateStruct(newObject) {
		zap.S().Errorf("Failed to validate struct of type stateQueue", newObject)
		return
	}

	marshal, err := json.Marshal(newObject)
	if err != nil {
		return
	}
	r.enqueue(marshal, 0)
	return
}
cmd\mqtt-to-postgresql\processState.go:57: 57-95 lines are duplicate of `cmd\mqtt-to-postgresql\processUniqueProduct.go:64-102` (dupl)
func (r StateHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseState(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processStoredRawMQTT.go:44:3: SA4005: ineffective assignment to field StoredRawMQTTHandler.finishedOldMqtt (staticcheck)
		r.finishedOldMqtt = true
		^
cmd\mqtt-to-postgresql\processStoredRawMQTT.go:58:7: shadow: declaration of "err" shadows declaration at line 55 (govet)
			_, err := r.ProcessPriorityQueue.Enqueue(item.Priority, item.Value)
			   ^
cmd\mqtt-to-postgresql\processStoredRawMQTT.go:64:9: ineffectual assignment to err (ineffassign)
		item, err = r.ProcessPriorityQueue.Dequeue()
		      ^
cmd\mqtt-to-postgresql\processStoredRawMQTT.go:68:2: SA4005: ineffective assignment to field StoredRawMQTTHandler.finishedOldMqtt (staticcheck)
	r.finishedOldMqtt = true
	^
cmd\mqtt-to-postgresql\processStoredRawMQTT.go:73:6: S1002: should omit comparison to bool constant, can be simplified to `!r.finishedOldMqtt` (gosimple)
		if r.finishedOldMqtt == false {
		   ^
cmd\mqtt-to-postgresql\processStoredRawMQTT.go:96:8: shadow: declaration of "err" shadows declaration at line 93 (govet)
				_, err := r.ProcessPriorityQueue.Enqueue(item.Priority, item.Value)
				   ^
cmd\mqtt-to-postgresql\processStoredRawMQTT.go:103:10: ineffectual assignment to err (ineffassign)
			item, err = r.ProcessPriorityQueue.Dequeue()
			      ^
cmd\mqtt-to-postgresql\processStoredRawMQTT.go:139:2: `(StoredRawMQTTHandler).EnqueueMQTT` - `recursionDepth` is unused (unparam)
	recursionDepth int64) {
	^
cmd\mqtt-to-postgresql\processUniqueProduct.go:64: 64-102 lines are duplicate of `cmd\mqtt-to-postgresql\processAddOrder.go:61-99` (dupl)
func (r UniqueProductHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseUniqueProduct(items, 0)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processValueData.go:73: 73-110 lines are duplicate of `cmd\mqtt-to-postgresql\processValueData.go:112-149` (dupl)
func (r ValueDataHandler) processI32() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeueI32()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseProcessValue(items)

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}
		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueueI32(faultyItem.Value, prio)
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processValueData.go:112: 112-149 lines are duplicate of `cmd\mqtt-to-postgresql\processValueData.go:73-110` (dupl)
func (r ValueDataHandler) processF64() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeueF64()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseProcessValueFloat64(items)

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}
		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueueF64(faultyItem.Value, prio)
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\processValueData.go:215:1: cognitive complexity 38 of func `(ValueDataHandler).EnqueueMQTT` is high (> 30) (gocognit)
func (r ValueDataHandler) EnqueueMQTT(
^
cmd\mqtt-to-postgresql\processValueString.go:54: 54-92 lines are duplicate of `cmd\mqtt-to-postgresql\processModifyState.go:60-98` (dupl)
func (r ValueStringHandler) process() {
	var items []*goque.PriorityItem
	loopsWithError := int64(0)
	for !r.shutdown {
		items = r.dequeue()
		if len(items) == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}
		faultyItems, err := storeItemsIntoDatabaseProcessValueString(items)

		// Empty the array, without de-allocating memory
		items = items[:0]
		for _, faultyItem := range faultyItems {
			var prio uint8
			prio = faultyItem.Priority + 1
			if faultyItem.Priority >= 255 {
				prio = 254
			}
			r.enqueue(faultyItem.Value, prio)
		}

		if err != nil {
			zap.S().Errorf("err: %s", err)
			switch GetPostgresErrorRecoveryOptions(err) {
			case Unrecoverable:
				ShutdownApplicationGraceful()
			}
		}

		if err != nil || len(faultyItems) > 0 {
			loopsWithError += 1
		} else {
			loopsWithError = 0
		}

		internal.SleepBackedOff(loopsWithError, 10000*time.Nanosecond, 1000*time.Millisecond)
	}
}
cmd\mqtt-to-postgresql\process_.go:14:6: `NewXHandler` is unused (deadcode)
func NewXHandler() (handler *XHandler) {
     ^
cmd\mqtt-to-postgresql\process_.go:46:2: SA5002: loop condition never changes or has a race condition (staticcheck)
	for !r.shutdown {
	^
cmd\mqtt-to-postgresql\queue.go:32:6: `reportQueueLength` is unused (deadcode)
func reportQueueLength(priorityQueue *goque.PriorityQueue) {
     ^
cmd\mqtt-to-postgresql\queueHandler.go:3:6: `QueueHandler` is unused (deadcode)
type QueueHandler interface {
     ^
cmd\mqtt-to-postgresql\statements.go:74:1: cognitive complexity 34 of func `(statementRegistry).Shutdown` is high (> 30) (gocognit)
func (r statementRegistry) Shutdown() (err error) {
^
cmd\sensorconnect\downloadPortModeData.go:51: line is 171 characters (lll)
// unmarshalModeInformation receives the response of the IO-Link-Master regarding its port modes. The function now processes the response and returns a port, portmode map.
cmd\sensorconnect\downloadPortModeData.go:155:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(payload))
	                           ^
cmd\sensorconnect\downloadPortModeData.go:239:2: naked return in func `getUsedPortsAndMode` with 130 lines of code (nakedret)
	return
	^
cmd\sensorconnect\downloadPortModeData.go:242: line is 144 characters (lll)
// extractIntFromString returns exactly one int from a given string. If no int or more then one int is inside of the string, an error is thrown.
cmd\sensorconnect\downloadSensorData.go:59: line is 171 characters (lll)
// unmarshalModeInformation receives the response of the IO-Link-Master regarding its port modes. The function now processes the response and returns a port, portmode map.
cmd\sensorconnect\downloadSensorData.go:75: line is 164 characters (lll)
// createSensorDataRequestBody creates the POST request body for ifm gateways. The body is made to simultaneously request sensordata of the ports 1 - numberOfPorts.
cmd\sensorconnect\downloadSensorData.go:125:2: naked return in func `createSensorDataRequestBody` with 50 lines of code (nakedret)
	return
	^
cmd\sensorconnect\downloadSensorData.go:128: line is 137 characters (lll)
// downloadSensorData sends a POST request to the given url with the given payload. It returns the body and an error in case of problems.
cmd\sensorconnect\downloadSensorData.go:131:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(payload))
	                           ^
cmd\sensorconnect\iolinkDeviceFinder.go:10:2: `log` is not in the allowlist (depguard)
	"log"
	^
cmd\sensorconnect\iolinkDeviceFinder.go:103: line is 214 characters (lll)
					"Failed to create topic %s, this can happen during initial startup, it might take up to 5 minutes for Kafka to startup. If you encounter this error, while Kafka is already running, please investigate further",
cmd\sensorconnect\iolinkDeviceFinder.go:155:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(payload))
	                           ^
cmd\sensorconnect\iolinkDeviceFinder.go:179:2: naked return in func `CheckGivenIpAddress` with 46 lines of code (nakedret)
	return
	^
cmd\sensorconnect\kafka.go:103:2: naked return in func `setupKafka` with 56 lines of code (nakedret)
	return
	^
cmd\sensorconnect\main.go:58:1: cognitive complexity 42 of func `main` is high (> 30) (gocognit)
func main() {
^
cmd\sensorconnect\main.go:187:2: `if slowdownMapRaw != ""` has complex nested blocks (complexity: 8) (nestif)
	if slowdownMapRaw != "" {
	^
cmd\sensorconnect\main.go:245: line is 138 characters (lll)
// continuousSensorDataProcessingV2 Spawns go routines for new devices, who will download,process and send data from sensors to Kafka/MQTT
cmd\sensorconnect\main.go:272:1: cognitive complexity 52 of func `continuousSensorDataProcessingDeviceDaemon` is high (> 30) (gocognit)
func continuousSensorDataProcessingDeviceDaemon(deviceInfo DiscoveredDeviceInformation) {
^
cmd\sensorconnect\mqtt.go:15:19: `newTLSConfig` - `clientID` is unused (unparam)
func newTLSConfig(clientID string) *tls.Config {
                  ^
cmd\sensorconnect\processIoddFiles.go:127: line is 149 characters (lll)
func AddNewDeviceToIoddFilesAndMap(ioddFilemapKey IoddFilemapKey, relativeDirectoryPath string, fileInfoSlice []os.FileInfo) ([]os.FileInfo, error) {
cmd\sensorconnect\processIoddFiles.go:148: line is 143 characters (lll)
		zap.S().Errorf("Unmarshaling of IoDevice %#v failed. Deleting iodd.xml file now and stopping container after that. Error: %v", ioddFile, err)
cmd\sensorconnect\processIoddFiles.go:159: line is 155 characters (lll)
// ReadIoddFiles Determines with oldFileInfoSlice if new .xml Iodd files are in IoddFiles folder -> if yes: unmarshals new files and caches in IoDevice Map
cmd\sensorconnect\processIoddFiles.go:161:25: Error return value of `filepath.Abs` is not checked (errcheck)
	absoluteDirectoryPath, _ := filepath.Abs(relativeDirectoryPath)
	                       ^
cmd\sensorconnect\processIoddFiles.go:185:3: ineffectual assignment to ioDevice (ineffassign)
		ioDevice := IoDevice{}
		^
cmd\sensorconnect\processIoddFiles_test.go:15:27: string `../sensorconnect/IoddFiles/` has 4 occurrences, make it a constant (goconst)
	relativeDirectoryPath := "../sensorconnect/IoddFiles/"
	                         ^
cmd\sensorconnect\processIoddFiles_test.go:104:31: `removeFilesFromDirectory` - `relativeDirectoryPath` always receives `relativeDirectoryPath` (`"../sensorconnect/IoddFiles/"`) (unparam)
func removeFilesFromDirectory(relativeDirectoryPath string) error {
                              ^
cmd\sensorconnect\processIoddFiles_test.go:105:25: Error return value of `filepath.Abs` is not checked (errcheck)
	absoluteDirectoryPath, _ := filepath.Abs(relativeDirectoryPath)
	                       ^
cmd\sensorconnect\processIoddFiles_test.go:117:1: cognitive complexity 84 of func `TestUnmarshalIoddFiles` is high (> 30) (gocognit)
func TestUnmarshalIoddFiles(t *testing.T) {
^
cmd\sensorconnect\processIoddFiles_test.go:193: line is 123 characters (lll)
	if !reflect.DeepEqual(reflect.TypeOf(ioDevice.ExternalTextCollection.PrimaryLanguage.Text[0].Id).Kind(), reflect.String) {
cmd\sensorconnect\processIoddFiles_test.go:202: line is 126 characters (lll)
	if !reflect.DeepEqual(reflect.TypeOf(ioDevice.ExternalTextCollection.PrimaryLanguage.Text[0].Value).Kind(), reflect.String) {
cmd\sensorconnect\processIoddFiles_test.go:207: line is 138 characters (lll)
	if !reflect.DeepEqual(ioDevice.ProfileBody.DeviceFunction.ProcessDataCollection.ProcessData.ProcessDataIn.Datatype.BitLength, uint(32)) {
cmd\sensorconnect\processIoddFiles_test.go:211: line is 165 characters (lll)
	if !reflect.DeepEqual(reflect.TypeOf(ioDevice.ProfileBody.DeviceFunction.ProcessDataCollection.ProcessData.ProcessDataIn.Datatype.BitLength).Kind(), reflect.Uint) {
cmd\sensorconnect\processIoddFiles_test.go:220: line is 199 characters (lll)
	if !reflect.DeepEqual(reflect.TypeOf(ioDevice.ProfileBody.DeviceFunction.ProcessDataCollection.ProcessData.ProcessDataIn.Datatype.RecordItemArray[1].SimpleDatatype.BitLength).Kind(), reflect.Uint) {
cmd\sensorconnect\processIoddFiles_test.go:225: line is 170 characters (lll)
	if !reflect.DeepEqual(ioDevice.ProfileBody.DeviceFunction.ProcessDataCollection.ProcessData.ProcessDataIn.Datatype.RecordItemArray[1].SimpleDatatype.Type, "UIntegerT") {
cmd\sensorconnect\processIoddFiles_test.go:229: line is 196 characters (lll)
	if !reflect.DeepEqual(reflect.TypeOf(ioDevice.ProfileBody.DeviceFunction.ProcessDataCollection.ProcessData.ProcessDataIn.Datatype.RecordItemArray[1].SimpleDatatype.Type).Kind(), reflect.String) {
cmd\sensorconnect\processIoddFiles_test.go:234: line is 168 characters (lll)
	if !reflect.DeepEqual(ioDevice.ProfileBody.DeviceFunction.ProcessDataCollection.ProcessData.ProcessDataIn.Datatype.RecordItemArray[1].Name.TextId, "TI_PD_SV_2_Name") {
cmd\sensorconnect\processIoddFiles_test.go:238: line is 188 characters (lll)
	if !reflect.DeepEqual(reflect.TypeOf(ioDevice.ProfileBody.DeviceFunction.ProcessDataCollection.ProcessData.ProcessDataIn.Datatype.RecordItemArray[1].Name.TextId).Kind(), reflect.String) {
cmd\sensorconnect\processIoddFiles_test.go:243: line is 150 characters (lll)
	if !reflect.DeepEqual(ioDevice.ProfileBody.DeviceFunction.ProcessDataCollection.ProcessData.ProcessDataIn.Datatype.RecordItemArray[1].BitOffset, 4) {
cmd\sensorconnect\processIoddFiles_test.go:247: line is 183 characters (lll)
	if !reflect.DeepEqual(reflect.TypeOf(ioDevice.ProfileBody.DeviceFunction.ProcessDataCollection.ProcessData.ProcessDataIn.Datatype.RecordItemArray[1].BitOffset).Kind(), reflect.Int) {
cmd\sensorconnect\processIoddFiles_test.go:252: line is 142 characters (lll)
	if !reflect.DeepEqual(len(ioDevice.ProfileBody.DeviceFunction.ProcessDataCollection.ProcessData.ProcessDataIn.Datatype.RecordItemArray), 4) {
cmd\sensorconnect\processSensorData.go:17: line is 130 characters (lll)
// processSensorData processes the donwnloaded information from one io-link-master and sends kafka messages with that information.
cmd\sensorconnect\processSensorData.go:19:1: cognitive complexity 35 of func `processSensorData` is high (> 30) (gocognit)
func processSensorData(
^
cmd\sensorconnect\processSensorData.go:112: line is 171 characters (lll)
				updateIoddIoDeviceMapChan <- ioddFilemapKey // send iodd filemap Key into update channel (updates can take a while, especially with bad internet -> do it concurrently)
cmd\sensorconnect\processSensorData.go:139: line is 132 characters (lll)
			// use the acquired info to process the raw data coming from the sensor correctly in to human readable data and attach to payload
cmd\sensorconnect\processSensorData.go:169: line is 124 characters (lll)
		case 4: // port inactive or problematic (custom port mode: not transmitted from IO-Link-Gateway, but set by sensorconnect)
cmd\sensorconnect\processSensorData.go:175: line is 173 characters (lll)
// processData turns raw sensor data into human readable data and attaches it to the payload. It can handle the input of datatype, datatypeRef and simpleDatatype structures.
cmd\sensorconnect\processSensorData.go:242: line is 148 characters (lll)
// getDatatypeFromDatatypeRef uses the given datatypeReference to find the actual datatype description in the datatypeReferenceArray and returns it.
cmd\sensorconnect\processSensorData.go:294: line is 181 characters (lll)
	// zap.S().Debugf("From the complete binary value %v the part %v was extracted. Left Index : %v, Right Index : %v", rawSensorOutputBinaryPadded, binaryValue, leftIndex, rightIndex)
cmd\sensorconnect\processSensorData.go:318: line is 148 characters (lll)
		// zap.S().Debugf("Starting to process rawSensorOutputBinaryPadded = %v with datatype %v iodd information", rawSensorOutputBinaryPadded, datatype)
cmd\sensorconnect\processSensorData.go:469: line is 194 characters (lll)
// checkSingleValuesAndValueRanges checks if value of record item is in a given valuerange or on a singlevalue. It returns the name of the singlevalue and an error if a ValueRange or SingleValue
cmd\sensorconnect\processSensorData.go:471: line is 142 characters (lll)
func checkSingleValuesAndValueRanges(item RecordItem, valueString string, datatype string, datatypeArray []Datatype) (name string, err error){
cmd\sensorconnect\processSensorData.go:473: line is 181 characters (lll)
		if  (reflect.DeepEqual(item.SimpleDatatype.ValueRange, "") && reflect.DeepEqual(item.SimpleDatatype.SingleValue, "")){ // simple datatype doesn't contain SingleValue or ValueRange
cmd\sensorconnect\processSensorData.go:508: line is 159 characters (lll)
	} else if !reflect.DeepEqual(item.DatatypeRef.DatatypeId, "") { // true if record item includes a datatypeRef -> look for type into DatatypeCollection with id
cmd\sensorconnect\processSensorData.go:515: line is 123 characters (lll)
		err = errors.New("DatatypeRef.DatatypeId is not in DatatypeCollection of Iodd file -> Datatype could not be determined.")
cmd\sensorconnect\processSensorData.go:538:17: Error return value of `strconv.ParseUint` is not checked (errcheck)
		outputString, _ := strconv.ParseUint(binaryValue, 2, 64)
		              ^
cmd\sensorconnect\processSensorData.go:554: line is 127 characters (lll)
// createDigitalInputPayload creates the upper json output body from an IoLink response to send via mqtt or kafka to the server
internal\cache.go:6:2: `github.com/go-redis/redis/v8` is not in the allowlist (depguard)
	"github.com/go-redis/redis/v8"
	^
internal\cache.go:8:2: `github.com/patrickmn/go-cache` is not in the allowlist (depguard)
	"github.com/patrickmn/go-cache"
	^
internal\cache.go:9:2: `github.com/patrickmn/go-cache` is not in the allowlist (depguard)
	_ "github.com/patrickmn/go-cache"
	^
internal\cache.go:10:2: `github.com/rung/go-safecast` is not in the allowlist (depguard)
	"github.com/rung/go-safecast"
	^
internal\cache.go:28:1: paramTypeCombine: func(redisURI string, redisURI2 string, redisURI3 string, redisPassword string, redisDB int, dryRun string) could be replaced with func(redisURI, redisURI2, redisURI3, redisPassword string, redisDB int, dryRun string) (gocritic)
func InitCache(redisURI string, redisURI2 string, redisURI3 string, redisPassword string, redisDB int, dryRun string) {
^
internal\cache.go:94:21: string `null` has 12 occurrences, make it a constant (goconst)
	} else if value == "null" {
	                   ^
internal\cache.go:173:2: naked return in func `GetCalculatateLowSpeedStatesFromCache` with 35 lines of code (nakedret)
	return
	^
internal\cache.go:213:2: hugeParam: configuration is heavy (97 bytes); consider passing it by pointer (gocritic)
	configuration datamodel.CustomerConfiguration) (data []datamodel.StateEntry, cacheHit bool) {
	^
internal\cache.go:244:2: naked return in func `GetStatesRawFromCache` with 36 lines of code (nakedret)
	return
	^
internal\cache.go:252:2: hugeParam: configuration is heavy (97 bytes); consider passing it by pointer (gocritic)
	configuration datamodel.CustomerConfiguration,
	^
internal\cache.go:285:2: hugeParam: configuration is heavy (97 bytes); consider passing it by pointer (gocritic)
	configuration datamodel.CustomerConfiguration) (data []datamodel.ShiftEntry, cacheHit bool) {
	^
internal\cache.go:316:2: naked return in func `GetRawShiftsFromCache` with 36 lines of code (nakedret)
	return
	^
internal\cache.go:353:1: paramTypeCombine: func(assetID uint32, from time.Time, to time.Time) (data []datamodel.CountEntry, cacheHit bool) could be replaced with func(assetID uint32, from, to time.Time) (data []datamodel.CountEntry, cacheHit bool) (gocritic)
func GetRawCountsFromCache(assetID uint32, from time.Time, to time.Time) (data []datamodel.CountEntry, cacheHit bool) {
^
internal\cache.go:383:2: naked return in func `GetRawCountsFromCache` with 31 lines of code (nakedret)
	return
	^
internal\cache.go:387:1: paramTypeCombine: func(assetID uint32, from time.Time, to time.Time, data []datamodel.CountEntry) could be replaced with func(assetID uint32, from, to time.Time, data []datamodel.CountEntry) (gocritic)
func StoreRawCountsToCache(assetID uint32, from time.Time, to time.Time, data []datamodel.CountEntry) {
^
internal\cache.go:475:1: paramTypeCombine: func(customerID string, location string, assetID string) (
	data []string,
	cacheHit bool) could be replaced with func(customerID, location, assetID string) (
	data []string,
	cacheHit bool) (gocritic)
func GetDistinctProcessValuesFromCache(customerID string, location string, assetID string) (
^
internal\cache.go:508:2: naked return in func `GetDistinctProcessValuesFromCache` with 34 lines of code (nakedret)
	return
	^
internal\cache.go:512:1: paramTypeCombine: func(customerID string, location string, assetID string) (
	data []string,
	cacheHit bool) could be replaced with func(customerID, location, assetID string) (
	data []string,
	cacheHit bool) (gocritic)
func GetDistinctProcessValuesStringFromCache(customerID string, location string, assetID string) (
^
internal\cache.go:545:2: naked return in func `GetDistinctProcessValuesStringFromCache` with 34 lines of code (nakedret)
	return
	^
internal\cache.go:549:1: paramTypeCombine: func(customerID string, location string, assetID string, data []string) could be replaced with func(customerID, location, assetID string, data []string) (gocritic)
func StoreDistinctProcessValuesStringToCache(customerID string, location string, assetID string, data []string) {
^
internal\cache.go:577:59: hugeParam: data is heavy (97 bytes); consider passing it by pointer (gocritic)
func StoreCustomerConfigurationToCache(customerID string, data datamodel.CustomerConfiguration) {
                                                          ^
internal\cache.go:602:1: paramTypeCombine: func(customerID string, location string, assetID string, data []string) could be replaced with func(customerID, location, assetID string, data []string) (gocritic)
func StoreDistinctProcessValuesToCache(customerID string, location string, assetID string, data []string) {
^
internal\cache.go:662:2: naked return in func `GetCustomerConfigurationFromCache` with 32 lines of code (nakedret)
	return
	^
internal\cache.go:666:79: captLocal: `DBassetID' should not be capitalized (gocritic)
func GetAssetIDFromCache(customerID string, location string, assetID string) (DBassetID uint32, cacheHit bool) {
                                                                              ^
internal\cache.go:702:2: naked return in func `GetAssetIDFromCache` with 37 lines of code (nakedret)
	return
	^
internal\cache.go:706:78: captLocal: `DBassetID' should not be capitalized (gocritic)
func StoreAssetIDToCache(customerID string, location string, assetID string, DBassetID uint32) {
                                                                             ^
internal\cache.go:729:46: captLocal: `DBassetID' should not be capitalized (gocritic)
func GetUniqueProductIDFromCache(aid string, DBassetID uint32) (uid uint32, cacheHit bool) {
                                             ^
internal\cache.go:765:2: naked return in func `GetUniqueProductIDFromCache` with 37 lines of code (nakedret)
	return
	^
internal\cache.go:828:2: naked return in func `GetProductIDFromCache` with 37 lines of code (nakedret)
	return
	^
internal\exponential_backoff.go:10:1: paramTypeCombine: func(retries int64, slotTime time.Duration, maximum time.Duration) (backoff time.Duration) could be replaced with func(retries int64, slotTime, maximum time.Duration) (backoff time.Duration) (gocritic)
func GetBackoffTime(retries int64, slotTime time.Duration, maximum time.Duration) (backoff time.Duration) {
^
internal\exponential_backoff.go:28:7: G404: Use of weak random number generator (math/rand instead of crypto/rand) (gosec)
	n := rand.Int63n(max)
	     ^
internal\exponential_backoff.go:43:1: paramTypeCombine: func(retries int64, slotTime time.Duration, maximum time.Duration) could be replaced with func(retries int64, slotTime, maximum time.Duration) (gocritic)
func SleepBackedOff(retries int64, slotTime time.Duration, maximum time.Duration) {
^
internal\hashing.go:14:6: Error return value of `h.Write` is not checked (errcheck)
		_, _ = h.Write(input)
		   ^
internal\helper.go:73:1: paramTypeCombine: func(functionName string, objectName string, now time.Time, v interface{}) could be replaced with func(functionName, objectName string, now time.Time, v interface{}) (gocritic)
func LogObject(functionName string, objectName string, now time.Time, v interface{}) {
^
internal\ioddfinder.go:36:2: rangeValCopy: each iteration copies 193 bytes (consider pointers or indexing) (gocritic)
	for i, file := range filemap {
	^
internal\ioddfinder.go:52:8: ioutilDeprecated: ioutil.WriteFile is deprecated, use os.WriteFile instead (gocritic)
	err = ioutil.WriteFile(absoluteFilePath, filemap[index].File, 0644)
	      ^
internal\ioddfinder.go:57:2: naked return in func `SaveIoddFile` with 39 lines of code (nakedret)
	return
	^
internal\ioddfinder.go:78:2: rangeValCopy: each iteration copies 153 bytes (consider pointers or indexing) (gocritic)
	for i, content := range ioddfinder.Content {
	^
internal\ioddfinder.go:125:2: naked return in func `GetIoddFile` with 65 lines of code (nakedret)
	return
	^
internal\ioddfinder.go:142:9: ioutilDeprecated: ioutil.ReadAll is deprecated, use io.ReadAll instead (gocritic)
	return ioutil.ReadAll(f)
	       ^
internal\ioddfinder.go:155:2: ineffectual assignment to status (ineffassign)
	status = 1
	^
internal\ioddfinder.go:178:14: G107: Potential HTTP request made with variable url (gosec)
	resp, err = http.Get(url)
	            ^
internal\ioddfinder.go:188:14: ioutilDeprecated: ioutil.ReadAll is deprecated, use io.ReadAll instead (gocritic)
	body, err = ioutil.ReadAll(resp.Body)
	            ^
internal\ioddfinder_test.go:44:13: Error return value of `os.MkdirAll` is not checked (errcheck)
	os.MkdirAll(filepath.Dir(relativeDirectoryPath), 0777)
	           ^
internal\ioddfinder_test.go:59:20: Error return value of `filepath.Abs` is not checked (errcheck)
	absoluteFilePath, _ := filepath.Abs(relativeFilePath)
	                  ^
internal\kafka.go:62:2: variable 'err' is only used in the if-statement (\internal\kafka.go:63:2); consider using short syntax (ifshort)
	err := KafkaConsumer.Close()
	^
internal\kafka.go:143:2: lostcancel: the cancel function is not used on all paths (possible context leak) (govet)
	ctx, cancel = context.WithDeadline(context.Background(), d)
	^
internal\kafka.go:147:3: lostcancel: this return statement may be reached without using the cancel var defined on line 143 (govet)
		return
		^
internal\kafka.go:182:2: naked return in func `CreateTopicIfNotExists` with 63 lines of code (nakedret)
	return
	^
internal\kafkaSharedTypes.go:166:1: cognitive complexity 56 of func `StartPutbackProcessor` is high (> 30) (gocognit)
func StartPutbackProcessor(
^
internal\kafkaSharedTypes.go:175:3: S1000: should use a simple channel send/receive instead of `select` with a single case (gosimple)
		select {
		^
internal\kafkaSharedTypes.go:211:5: `if rawKafkaKey == nil` has complex nested blocks (complexity: 8) (nestif)
				if rawKafkaKey == nil {
				^
internal\kafkaSharedTypes.go:355:3: S1000: should use a simple channel send/receive instead of `select` with a single case (gosimple)
		select {
		^
internal\kafkaTopics.go:4:2: `github.com/hashicorp/golang-lru` is not in the allowlist (depguard)
	"github.com/hashicorp/golang-lru"
	^
internal\kafkaTopics.go:56:2: `if submatch[11] == nil` has complex nested blocks (complexity: 5) (nestif)
	if submatch[11] == nil {
	^
internal\kafkaTopics_test.go:4:2: `github.com/go-playground/assert/v2` is not in the allowlist (depguard)
	"github.com/go-playground/assert/v2"
	^
pkg\datamodel\conversion.go:4:22: captLocal: `OldState' should not be capitalized (gocritic)
func ConvertOldToNew(OldState int) (NewState int) {
                     ^
pkg\datamodel\conversion.go:52:2: naked return in func `ConvertOldToNew` with 49 lines of code (nakedret)
	return
	^
pkg\datamodel\conversion.go:56:22: captLocal: `NewState' should not be capitalized (gocritic)
func ConvertNewToOld(NewState int) (OldState int) {
                     ^
pkg\datamodel\conversion.go:104:2: naked return in func `ConvertNewToOld` with 49 lines of code (nakedret)
	return
	^
pkg\datamodel\stateModel.go:19: line is 129 characters (lll)
	// OperatorInteractionState means that the asset is in an unspecified state, because the operator has stopped the asset manually
pkg\datamodel\stateModel.go:35: line is 135 characters (lll)
	// MissingBottleCapsRinneState means that the asset has a congestion or deficiency in the bypass flow, specifically "Kronkorken Rinne"
pkg\datamodel\stateModel.go:38: line is 143 characters (lll)
	// MissingBottleCapsUebergabeState means that the asset has a congestion or deficiency in the bypass flow, specifically "Kronkorken Uebergabe"
pkg\datamodel\stateModel.go:113: line is 136 characters (lll)
// IsSpecifiedStop checks whether the asset is in an specified stop (is not running, is not a microstop or unknown stop, and is defined)
pkg\datamodel\stateModelString.go:17:1: cyclomatic complexity 105 of func `ConvertStateToString` is high (> 30) (gocyclo)
func ConvertStateToString(state int, languageCode LanguageCode) (stateString string) {
^
pkg\datamodel\stateModelString.go:21: 21-94 lines are duplicate of `pkg\datamodel\stateModelString.go:94-167` (dupl)
	if languageCode == 0 { // GERMAN
		switch state {
		case ProducingAtFullSpeedState:
			stateString = "Maschine läuft"
		case ProducingAtLowerThanFullSpeedState:
			stateString = "Maschine läuft mit verringerter Geschwindigkeit"
		case UnknownState:
			stateString = "Keine Daten"
		case IdleState:
			stateString = "Bereit"
		case OperatorInteractionState:
			stateString = "Bedienereingriff"
		case UnspecifiedStopState:
			stateString = "Unbekannter Stopp"
		case MicrostopState:
			stateString = "Mikrostopp"
		case InletJamState:
			stateString = "Mangel am Einlauf"
		case OutletJamState:
			stateString = "Mangel am Auslauf"
		case CongestionBypassState:
			stateString = "Mangel an Hilfsmaterialien"
		case MissingBottleCapsRinneState:
			stateString = "Mangel an Kronkorken (Rinne)"
		case MissingBottleCapsUebergabeState:
			stateString = "Mangel an Kronkorken (Übergabe)"
		case MaterialIssueOtherState:
			stateString = "Sonstige Materialprobleme"
		case ChangeoverState:
			stateString = "Rüsten"
		case ChangeoverPreparationState:
			stateString = "Vorbereitung"
		case ChangeoverPostprocessingState:
			stateString = "Nachbereitung"
		case CleaningState:
			stateString = "Reinigen"
		case EmptyingState:
			stateString = "Leeren"
		case SettingUpState:
			stateString = "Vorbereiten"
		case OperatorNotAtMachineState:
			stateString = "Maschinenbediener fehlt"
		case OperatorBreakState:
			stateString = "Pause"
		case NoShiftState:
			stateString = "Keine Schicht"
		case NoOrderState:
			stateString = "Kein Auftrag"
		case EquipmentFailureState:
			stateString = "Maschinenstörung"
		case EquipmentFailureStateWelder:
			stateString = "Maschinenstörung Schweißer"
		case EquipmentFailureStateExpender:
			stateString = "Maschinenstörung Spreizer"
		case EquipmentFailureStatePalletizer:
			stateString = "Maschinenstörung Palettierer"
		case EquipmentFailureStateUnderbody:
			stateString = "Maschinenstörung Unterboden"
		case EquipmentFailureStateTopcover:
			stateString = "Maschinenstörung Oberboden"
		case ExternalFailureState:
			stateString = "Externe Störung"
		case ExternalInterferenceState:
			stateString = "Sonstige externe Störung"
		case CraneNotAvailableState:
			stateString = "Kran nicht verfügbar"
		case PreventiveMaintenanceStop:
			stateString = "Wartung"
		case TechnicalOtherStop:
			stateString = "Sonstige technische Störung"
		default:
			stateString = fmt.Sprintf("Unbekannter Zustand %d", state)
		}
	} else if languageCode == 2 { // TURKISH
pkg\datamodel\stateModelString.go:94: 94-167 lines are duplicate of `pkg\datamodel\stateModelString.go:21-94` (dupl)
	} else if languageCode == 2 { // TURKISH
		switch state {
		case ProducingAtFullSpeedState:
			stateString = "Makine Çalışıyor"
		case ProducingAtLowerThanFullSpeedState:
			stateString = "Makine Düşük Hızda Çalışıyor"
		case UnknownState:
			stateString = "Veri Yok"
		case IdleState:
			stateString = "Hazır"
		case OperatorInteractionState:
			stateString = "Operatör Müdahalesi"
		case UnspecifiedStopState:
			stateString = "Bilinmeyen Duruş"
		case MicrostopState:
			stateString = "Kısa Duruş"
		case InletJamState:
			stateString = "Mangel am Einlauf"
		case OutletJamState:
			stateString = "Mangel am Auslauf"
		case CongestionBypassState:
			stateString = "Yarı Mamül Eksikliği"
		case MissingBottleCapsRinneState:
			stateString = "Mangel an Kronkorken (Rinne)"
		case MissingBottleCapsUebergabeState:
			stateString = "Mangel an Kronkorken (Übergabe)"
		case MaterialIssueOtherState:
			stateString = "Diğer Hammadde Sorunları"
		case ChangeoverState:
			stateString = "Model Değişimi"
		case ChangeoverPreparationState:
			stateString = "Model Değişim Hazırlık"
		case ChangeoverPostprocessingState:
			stateString = "Model Değişim Son Kontrol"
		case CleaningState:
			stateString = "Temizlik"
		case EmptyingState:
			stateString = "Boşaltma"
		case SettingUpState:
			stateString = "Hazırlama"
		case OperatorNotAtMachineState:
			stateString = "Operatör Makinede Değil"
		case OperatorBreakState:
			stateString = "Mola"
		case NoShiftState:
			stateString = "Vardiya Yok"
		case NoOrderState:
			stateString = "Sipariş Yok"
		case EquipmentFailureState:
			stateString = "Makine Arızası"
		case EquipmentFailureStateWelder:
			stateString = "Makine Arızası - Kaynak"
		case EquipmentFailureStateExpender:
			stateString = "Makine Arızası - Tutucu"
		case EquipmentFailureStatePalletizer:
			stateString = "Makine Arızası - Palet"
		case EquipmentFailureStateUnderbody:
			stateString = "Makine Arızası - Gövde"
		case EquipmentFailureStateTopcover:
			stateString = "Makine Arızası - Üst Taraf"
		case ExternalFailureState:
			stateString = "Harici Arıza"
		case ExternalInterferenceState:
			stateString = "Dış Müdahale"
		case CraneNotAvailableState:
			stateString = "Vinç Mevcut Değil"
		case PreventiveMaintenanceStop:
			stateString = "Bakım"
		case TechnicalOtherStop:
			stateString = "Diğer Teknik Arızalar"
		default:
			stateString = fmt.Sprintf("Bilinmeyen Durum %d", state)
		}
	} else { // ENGLISH
pkg\datamodel\stateModelString.go:238:2: naked return in func `ConvertStateToString` with 222 lines of code (nakedret)
	return
	^
